<?xml version="1.0" encoding="UTF-8"?>
<!--
 If not stated otherwise in this file or this component's Licenses.txt file the
 following copyright and licenses apply:

 Copyright 2016 RDK Management

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Anand P S"/><meta name="DCTERMS.issued" content="2014-10-10T03:54:24" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Nampoothiri, Sreelal (Contractor)"/><meta name="DCTERMS.modified" content="2016-05-02T19:25:39" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.Default { font-family:Arial; padding:2.01pt; }
	.ce1 { background-color:#558ed5; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce10 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce11 { background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce12 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce13 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce14 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; }
	.ce15 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce16 { background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce17 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce18 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:center ! important; }
	.ce19 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:top; writing-mode:page; text-align:center ! important; }
	.ce2 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce20 { background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:top; writing-mode:page; text-align:center ! important; }
	.ce21 { background-color:transparent; border-style:none; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce22 { background-color:transparent; border-style:none; color:#ffffff; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce23 { background-color:transparent; border-style:none; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce24 { padding:2.01pt; font-family:Arial; }
	.ce3 { background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce4 { background-color:transparent; border-style:none; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce5 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce6 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce7 { padding:2.01pt; font-family:Arial; background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce8 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce9 { background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.co1 { width:93.54pt; }
	.co10 { width:111.8pt; }
	.co11 { width:104.66pt; }
	.co12 { width:159.36pt; }
	.co13 { width:92.75pt; }
	.co14 { width:225.95pt; }
	.co2 { width:180.74pt; }
	.co3 { width:68.94pt; }
	.co4 { width:101.51pt; }
	.co5 { width:95.16pt; }
	.co6 { width:112.59pt; }
	.co7 { width:173.65pt; }
	.co8 { width:124.44pt; }
	.co9 { width:50.74pt; }
	.ro1 { height:123.76pt; }
	.T1 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; text-decoration:underline; font-style:normal; text-shadow:none; }
	.T2 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; font-style:normal; text-shadow:none; text-decoration:none ! important; }
	.T3 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T4 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="margin-top:54pt; margin-bottom:54pt; margin-left:50.4pt; margin-right:50.4pt; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="144"/><col width="279"/><col width="106"/><col width="106"/><col width="156"/><col width="147"/><col width="174"/><col width="268"/><col width="192"/><col width="78"/><col width="172"/><col width="161"/><col width="246"/><col width="143"/><col width="348"/><col width="348"/></colgroup><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:180.74pt; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:68.94pt; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:68.94pt; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:101.51pt; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:95.16pt; " class="ce1"><p>API's / Interface Used</p></td><td style="text-align:left;width:112.59pt; " class="ce1"><p>Input Parameters</p><p>(<span class="T1">API name</span><span class="T2">: parameter type – value) / </span></p><p><span class="T3">Interface Input</span></p></td><td style="text-align:left;width:173.65pt; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:124.44pt; " class="ce1"><p>Exp Output</p></td><td style="text-align:left;width:50.74pt; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:111.8pt; " class="ce1"><p>Test Stub Interface</p></td><td style="text-align:left;width:104.66pt; " class="ce1"><p>Test script</p></td><td style="text-align:left;width:159.36pt; " class="ce13"><p>Remarks</p></td><td style="text-align:left;width:92.75pt; " class="ce18"><p>Release version</p></td><td style="text-align:left;width:225.95pt; " class="ce22"> </td><td style="text-align:left;width:225.95pt; " class="ce22"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_01</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To initialize the DTCP-IP Manager sub-system.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrInitialize(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for intializing the DTCP</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_Init_01</p></td><td style="text-align:left;width:159.36pt; " class="ce2"><p>Note: TestMgr_DTCP_Test_Execute is a common function for all the DTCP APIs. The first parameter is function name followed by arguments/parameters.</p></td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce23"> </td><td style="text-align:left;width:225.95pt; " class="ce23"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_02</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To start DTCP-IP source and begins listening for AKE requests on the specified interface and port number.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>ifName':'lan0','port':5000</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method  to start source.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_StartSource_02</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce23"> </td><td style="text-align:left;width:225.95pt; " class="ce23"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_03</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To stop DTCP-IP source and remove AKE request listener added with StartSource()</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrStartSource</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>ifName':'lan0','port':5000</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method to stop encryprting or decrypting.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_StopSource_03</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce23"> </td><td style="text-align:left;width:225.95pt; " class="ce23"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_04</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To create a new authenticated session with a remote DTCP-IP sink.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to create source session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateSrcSess_04</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_05</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To create a new authenticated session with a remote DTCP-IP source.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrStartSource</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p> 'srcIp':lan0Ip,'srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to create sink session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateSinkSess_05</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_06</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To process(encrypt) the provided buffers and create a DTCP-IP packet and return decrypted buffers.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSourceSession</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p> </p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to process DTCP packet</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_ProcessSrcPacket_06</p></td><td style="text-align:left;width:159.36pt; " class="ce2"><p>Renamed from DTCP_ProcessSrcPacket_06 to DTCP_ProcessPacket_06</p></td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M30</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_07</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To release DTCP-IP packet. The processed packet may contain DTCP Manager allocated/owned buffers/memory - this call frees up these resources. </p><p> </p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSourceSession, DTCPMgrProcessPacket</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p> </p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to Release the packet.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_ReleaseSrcPacket_07</p></td><td style="text-align:left;width:159.36pt; " class="ce2"><p>Renamed from DTCP_ReleaseSrcPacket_07 to DTCP_ReleasePacket_07</p></td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M30</p></td><td style="text-align:left;width:225.95pt; " class="ce23"> </td><td style="text-align:left;width:225.95pt; " class="ce23"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_08</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To stop an active DTCP-IP source session.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSourceSession</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_DeleteSrcSess_08</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_09</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To retrieve the total number of active sessions for the specified device type.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p> 'deviceType':2</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to get num of active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_GetNumSessions_09</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_10</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To retrieve information related to an active source session.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSourceSession</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to get session info</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_GetSrcSessInfo_10</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_11</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To set DTCP Manager's logging verbosity level.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrSetLogLevel(int level);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>"level":3</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to set the log level.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_SetLogLevel_11</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_12</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To retrieve information related to an active sink session.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSinkSession</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p> 'srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_GetSinkSessInfo_12</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_13</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To create a new authenticated session with a remote DTCP-IP sink using invalid sink IP address.</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>"sinkIp":'0.42.42.42'</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateSrcSess_InvalidIp_13</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_14</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To create a new authenticated session with a remote DTCP-IP source with an invalid source IP address.</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p> 'srcIp':'0.42.42.42'</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateSinkSess_InvalidIp_14</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_15</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To retrieve the total number of active sessions for an invalid device type.</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>deviceType':3</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_GetNumSess_InvalidType_15</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_16</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To set DTCP Manager's logging verbosity level to an invalid value.</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrSetLogLevel(int level);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>"level":50</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_SetInvalidLogLevel_16</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_17</p></td><td style="text-align:left;width:180.74pt; " class="ce5"><p>To start and stop DTCP-IP source on multiple interfaces and port number.</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>ifName':["lan0","lo","eth1"],'port':[5000,5010,8080]</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_StartStopSrc_MultiIface_17</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_18</p></td><td style="text-align:left;width:180.74pt; " class="ce5"><p>To retrieve the total number of active sink sessions.</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>deviceType':1</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_GetNumSessions_Sink_18</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_19</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To retrieve the total number of active source sessions.</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>deviceType':0</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_GetNumSessions_Src_19</p></td><td style="text-align:left;width:159.36pt; " class="ce2"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_20</p></td><td style="text-align:left;width:180.74pt; " class="ce6"><p>To stop an active DTCP-IP sink session.</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSinkSession</p></td><td style="text-align:left;width:95.16pt; " class="ce6"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce6"><p>ifName':'lan0','port':5000</p><p>'srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce6"><p>DTCP_DeleteSinkSess_20</p></td><td style="text-align:left;width:159.36pt; " class="ce14"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_21</p></td><td style="text-align:left;width:180.74pt; " class="ce6"><p>To stop DTCP-IP source without adding AKE reques listeners with StartSource()</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce6"><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce6"><p>None</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce6"><p>DTCP_StopWithoutStartSrc_21</p></td><td style="text-align:left;width:159.36pt; " class="ce14"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_22</p></td><td style="text-align:left;width:180.74pt; " class="ce6"><p>To start DTCP-IP source on an invalid TCP/IP port number.</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce6"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p></td><td style="text-align:left;width:112.59pt; " class="ce6"><p>ifName':'lan0','port':23</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce12"><p>DTCP_StartSource_InvalidPort_22</p></td><td style="text-align:left;width:159.36pt; " class="ce14"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_23</p></td><td style="text-align:left;width:180.74pt; " class="ce6"><p>To start DTCP-IP source on an invalid interface name.</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce6"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p></td><td style="text-align:left;width:112.59pt; " class="ce6"><p>ifName':'127.0.0.1','port':5000</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce6"><p>DTCP_StartSource_InvalidIfName_23</p></td><td style="text-align:left;width:159.36pt; " class="ce14"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_24</p></td><td style="text-align:left;width:180.74pt; " class="ce6"><p>To retrieve information related to a null session handle.</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce6"><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p></td><td style="text-align:left;width:112.59pt; " class="ce6"><p>handle=0</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce6"><p>DTCP_GetSessInfo_Neg_24</p></td><td style="text-align:left;width:159.36pt; " class="ce14"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_25</p></td><td style="text-align:left;width:180.74pt; " class="ce6"><p>To create a new authenticated session with a remote DTCP-IP source using invalid TCP/IP port.</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrInitialize(void);</p><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p><p> </p></td><td style="text-align:left;width:112.59pt; " class="ce6"><p>srcIp':'127.0.0.1','srcPort':0,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce6"><p>DTCP_CreateSinkSess_InvalidPort_25</p></td><td style="text-align:left;width:159.36pt; " class="ce14"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce24"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_26</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To process null sink and source session handles.</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>session=0</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_ProcessPacket_Neg_26</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce3"><p>CT_DTCP_27</p></td><td style="text-align:left;width:180.74pt; " class="ce3"><p>To process DTCP-IP packet and return decrypted buffers.</p></td><td style="text-align:left;width:68.94pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce3"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce3"><p>DTCPMgrInitialize, DTCPMgrCreateSinkSession</p></td><td style="text-align:left;width:95.16pt; " class="ce3"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p><p> </p></td><td style="text-align:left;width:112.59pt; " class="ce3"><p>ifName':'lan0','port':5000</p><p>'srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce9"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce11"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce3"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce3"><p>DTCP_ProcessSinkPacket_27</p></td><td style="text-align:left;width:159.36pt; " class="ce16"><p>Removed</p></td><td style="text-align:left;width:92.75pt; " class="ce20"><p>M30</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce3"><p>CT_DTCP_28</p></td><td style="text-align:left;width:180.74pt; " class="ce3"><p>To release sink DTCP-IP packet. The processed packet may contain DTCP Manager allocated/owned buffers/memory - this call frees up these resources. </p></td><td style="text-align:left;width:68.94pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce7"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce3"><p>DTCPMgrInitialize, DTCPMgrCreateSinkSession, DTCPMgrProcessPacket</p></td><td style="text-align:left;width:95.16pt; " class="ce3"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p><p> </p></td><td style="text-align:left;width:112.59pt; " class="ce3"><p>ifName':'lan0','port':5000</p><p>'srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce9"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce11"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce3"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce3"><p>DTCP_ReleaseSinkPacket_28</p></td><td style="text-align:left;width:159.36pt; " class="ce16"><p>Removed</p></td><td style="text-align:left;width:92.75pt; " class="ce20"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_29</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To stop a null DTCP-IP sink session.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>session=0</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_DeleteSinkSess_Neg_29</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_30</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To stop a null DTCP-IP source session.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>session=0</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_DeleteSrcSess_Neg_30</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_31</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To initialize the DTCP-IP Manager sub-system multiple times.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrInitialize(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_Init_Stress_31</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_32</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To stop DTCP-IP source without deleting active source and sink sessions. </p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>ifName':'lan0','port':5000</p><p>'srcIp':ip,'srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p><p>'sinkIp':ip,'keyLabel':0,'pcpPacketSize':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_StopSrcwithActiveSessions_32</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_33</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To create a new authenticated source session with a remote DTCP-IP sink without invoking StartSource().</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>sinkIp':ip,'keyLabel':0,'pcpPacketSize':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateSrcSessWithoutStartSrc_33</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_34</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To create a new authenticated sink session with a remote DTCP-IP source without invoking StartSource().</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>srcIp':ip,'srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateSinkSessWithoutStartSrc_34</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_35</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To check that max of only 1 sink session is created since DTCP sink session is persistent and on every channel change dtcp uses the same session. </p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>ifName':'lan0','port':[5000,5009]</p><p>'srcIp':ip,'srcPort':port,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateMaxSinkSess_35</p></td><td style="text-align:left;width:159.36pt; " class="ce17"><p>Skipped from testsuite as per PACXG1V3-5022. This test case is DTCP library vendor specific</p></td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M29</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_36</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To check that max of 8 source sessions can be created if no sink sessions are there</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>sinkIp':lan0-ip,'keyLabel':0,'pcpPacketSize':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateMaxSrcSess_36</p></td><td style="text-align:left;width:159.36pt; " class="ce17"><p>Skipped from testsuite as per PACXG1V3-5022. This test case is DTCP library vendor specific</p></td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M29</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_37</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To start multiple DTCP-IP source listeners on different interfaces and ports.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>ifName':'lan0','port':[6000...6059]</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_MultiStartSource_37</p></td><td style="text-align:left;width:159.36pt; " class="ce17"><p>Skipped from testsuite as per PACXG1V3-5022. This test case is DTCP library vendor specific</p></td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M29</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_38</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To create and remove multiple AKE request listeners using startsource/stopsource</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrStartSource</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>ifName':'lan0','port':[8000,8001,8002,8003,8004]</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_StopAllSources_38</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_39</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To create a new authenticated sink session with loopback IP address as remote DTCP-IP source.</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrStartSource</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_CreateSinkSessOnLoSrcIp_39</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce2"><p>CT_DTCP_40</p></td><td style="text-align:left;width:180.74pt; " class="ce2"><p>To verify successful exchange of key label from streaming request</p></td><td style="text-align:left;width:68.94pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:68.94pt; " class="ce6"><p>XG1</p></td><td style="text-align:left;width:101.51pt; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:95.16pt; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p><p> </p></td><td style="text-align:left;width:112.59pt; " class="ce2"><p>ifName':'lan0','port':5000</p><p>'srcIp':lanip,'srcPort':5000,'uniqueKey':1,'maxPacketSize':4096</p><p>'sinkIp':'127.0.0.1','keyLabel':87,'pcpPacketSize':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:173.65pt; " class="ce5"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:124.44pt; " class="ce10"><p>Checkpoint 1 <span class="T4">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:50.74pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:111.8pt; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:104.66pt; " class="ce2"><p>DTCP_UniqueKeyExchange_40</p></td><td style="text-align:left;width:159.36pt; " class="ce15"> </td><td style="text-align:left;width:92.75pt; " class="ce19"><p>M21</p></td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce4"> </td><td style="text-align:left;width:180.74pt; " class="ce4"> </td><td style="text-align:left;width:68.94pt; " class="ce4"> </td><td style="text-align:left;width:68.94pt; " class="ce4"> </td><td style="text-align:left;width:101.51pt; " class="ce4"> </td><td style="text-align:left;width:95.16pt; " class="ce8"> </td><td style="text-align:left;width:112.59pt; " class="ce4"> </td><td style="text-align:left;width:173.65pt; " class="ce4"> </td><td style="text-align:left;width:124.44pt; " class="ce4"> </td><td style="text-align:left;width:50.74pt; " class="ce8"> </td><td style="text-align:left;width:111.8pt; " class="ce4"> </td><td style="text-align:left;width:104.66pt; " class="ce4"> </td><td style="text-align:left;width:159.36pt; " class="ce4"> </td><td style="text-align:left;width:92.75pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:93.54pt; " class="ce4"> </td><td style="text-align:left;width:180.74pt; " class="ce4"> </td><td style="text-align:left;width:68.94pt; " class="ce4"> </td><td style="text-align:left;width:68.94pt; " class="ce4"> </td><td style="text-align:left;width:101.51pt; " class="ce4"> </td><td style="text-align:left;width:95.16pt; " class="ce8"> </td><td style="text-align:left;width:112.59pt; " class="ce4"> </td><td style="text-align:left;width:173.65pt; " class="ce4"> </td><td style="text-align:left;width:124.44pt; " class="ce4"> </td><td style="text-align:left;width:50.74pt; " class="ce8"> </td><td style="text-align:left;width:111.8pt; " class="ce4"> </td><td style="text-align:left;width:104.66pt; " class="ce4"> </td><td style="text-align:left;width:159.36pt; " class="ce4"> </td><td style="text-align:left;width:92.75pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="ce21"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr></table></body></html>
