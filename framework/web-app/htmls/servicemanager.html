<?xml version="1.0" encoding="UTF-8"?>
<!--
 If not stated otherwise in this file or this component's Licenses.txt file the
 following copyright and licenses apply:

 Copyright 2016 RDK Management

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="nishab"/><meta name="DCTERMS.issued" content="2016-11-17T11:06:14" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Nampoothiri, Sreelal (Contractor)"/><meta name="DCTERMS.modified" content="2017-01-03T17:13:12" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.Default { font-family:Calibri; vertical-align:bottom; color:#000000; font-size:11pt; }
	.ce1 { background-color:#bdd7ee; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:12pt; font-style:normal; font-weight:bold; margin-left:0pt; text-shadow:none; font-family:Times New Roman; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce10 { color:#000000; font-size:11pt; font-family:Calibri; vertical-align:bottom; margin-left:0pt; writing-mode:page; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce11 { color:#000000; font-size:12pt; font-family:Arial; vertical-align:middle; background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; margin-left:0pt; writing-mode:page; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce12 { background-color:#bdd7ee; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:12pt; font-style:normal; font-weight:bold; margin-left:0pt; text-shadow:none; font-family:Times New Roman; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce13 { color:#000000; font-size:12pt; font-family:Calibri; vertical-align:middle; text-align:center ! important; margin-left:0pt; writing-mode:page; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce14 { color:#000000; font-size:11pt; font-family:Calibri; vertical-align:middle; border-width:0.0261cm; border-style:solid; border-color:#000000; margin-left:0pt; writing-mode:page; }
	.ce2 { background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.ce3 { color:#000000; font-size:10pt; font-family:Arial; vertical-align:middle; background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; margin-left:0pt; writing-mode:page; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce4 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.ce5 { color:#000000; font-size:11pt; font-family:Calibri; vertical-align:bottom; margin-left:0pt; writing-mode:page; }
	.ce6 { color:#000000; font-size:10pt; font-family:Arial; vertical-align:middle; background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; margin-left:0pt; writing-mode:page; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce7 { color:#000000; font-size:10pt; font-family:Arial; vertical-align:middle; border-width:0.0261cm; border-style:solid; border-color:#000000; margin-left:0pt; writing-mode:page; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce8 { color:#000000; font-size:11pt; font-family:Calibri; vertical-align:middle; background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; margin-left:0pt; writing-mode:page; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce9 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.co1 { width:388.09pt; }
	.co10 { width:142.84pt; }
	.co11 { width:50.8pt; }
	.co12 { width:114.29pt; }
	.co13 { width:49.21pt; }
	.co14 { width:134.16pt; }
	.co15 { width:124.61pt; }
	.co2 { width:197.66pt; }
	.co3 { width:120.61pt; }
	.co4 { width:82.54pt; }
	.co5 { width:138.9pt; }
	.co6 { width:127.81pt; }
	.co7 { width:288.91pt; }
	.co8 { width:217.45pt; }
	.co9 { width:520.64pt; }
	.ro1 { height:31.49pt; }
	.ro2 { height:170.11pt; }
	.T1 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T2 { font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T3 { font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; color:#000000; font-family:Calibri; font-size:11pt; }
	.T4 { font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; font-family:Arial; font-size:10pt; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="max-width:595.3pt;margin-top:54pt; margin-bottom:54pt; margin-left:50.4pt; margin-right:50.4pt; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="598"/><col width="305"/><col width="186"/><col width="127"/><col width="214"/><col width="197"/><col width="445"/><col width="335"/><col width="803"/><col width="220"/><col width="78"/><col width="176"/><col width="76"/><col width="207"/><col width="192"/><col width="78"/></colgroup><tr class="ro1"><td style="text-align:left;width:388.09pt; " class="ce1"><p>Test Script</p></td><td style="text-align:left;width:197.66pt; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:120.61pt; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:82.54pt; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:138.9pt; " class="ce1"><p>Supported Box Type</p></td><td style="text-align:left;width:127.81pt; " class="ce1"><p>Test Prerequisites</p></td><td style="text-align:left;width:288.91pt; " class="ce1"><p>RDK Interface</p></td><td style="text-align:left;width:217.45pt; " class="ce1"><p>Input Parameters</p></td><td style="text-align:left;width:520.64pt; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:142.84pt; " class="ce1"><p>Expected Output</p></td><td style="text-align:left;width:50.8pt; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:114.29pt; " class="ce1"><p>Test Stub Interface</p></td><td style="text-align:left;width:49.21pt; " class="ce1"><p>Skipped</p></td><td style="text-align:left;width:134.16pt; " class="ce1"><p>Update Release Version</p></td><td style="text-align:left;width:124.61pt; " class="ce12"><p>Remarks</p></td><td style="text-align:left;width:50.8pt; " class="ce13"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_RegisterService test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_1</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Registering and DeRegistering services from servicemanager</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2. Service_Manager_Agent will register a given service with ServiceManager component.</span></p><p><span class="T1">3. On Success of registerService ,Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">4. Service_Manager_Agent will return SUCCESS/FAILURE status based on the return value of “unregisterService” API.</span></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce11"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_UnRegisterService test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_2</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – DeRegistering services from servicemanager without registering .</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>unregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. Service_Manager_Agent will deregister a given service from ServiceManager component without registering</p><p>3. Service_Manager_Agent will return SUCCESS/FAILURE status based on the return value of  “un<span class="T1">registerService” API.</span></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of API for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p> </p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_DoesServiceExist Negative test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_4</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – checking the service's registration status after deregistering.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>bool doesServiceExist(const QString&amp; )</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct </p><p>DoesServiceExist : Qstring-serviceName</p><p>unregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2. Service_Manager_Agent will register a given service with ServiceManager component.</span></p><p><span class="T1">3. On Success of registerService Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">4.Service_Manager_Agent will check for the service registration status with ServiceManager.</span></p><p><span class="T1">5. Service_Manager_Agent will return SUCCESS/FAILURE status based on the return value of  APIs.</span></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_UnRegisterService</p><p><span class="T1">3.TestMgr_SM_DoesServiceExist</span></p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_GetRegisteredService test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_5</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Getting list of registered services.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct)</p><p>QList&lt;QString&gt; getRegisteredServices()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>RegisterService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetRegisteredServices : Null</p><p>unregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2. Service_Manager_Agent will register a given service with ServiceManager component.</span></p><p><span class="T1">3. On Success of registerService ,Service_Manager_Agent will get a list of services registered with ServiceManager component.</span></p><p><span class="T1">4. Service_Manager_Agent will check for the presence of  the service(registered in step2) in the list of registered service .</span></p><p><span class="T1">5. Service_Manager_Agent will return SUCCESS/FAILURE status based on step 4.</span></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Check the given registered service in the list of registered service.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_GetRegisteredServices</p><p>3.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_GetGlobal Service test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_6</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Getting an instance of registered service.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>QString getName()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p> </p><p> </p><p>RegisterService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>UnregisterService : Qstring-serviceName</p><p> </p><p> </p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1.TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given service with ServiceManager component.</span></p><p><span class="T1">3. On Success of registerService , Service_Manager_Agent will get an instance of a given service.</span></p><p><span class="T1">4.Service_Manager_Agent will get the name of the service and compare with the queried service.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6.Service_Manager_Agent will return SUCCESS/FAILURE status based on API's return value and step4 .</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Check the Name with the name of the queried service.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_GetGlobalService</p><p>3.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_SetApiVersion test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_8</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Get and Set service's API version number</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>unsigned int getApiVersionNumber()</p><p>Void setApiVersionNumber(unsigned int )</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring - serviceName</p><p>ApiVersionNumber:  unsigned int – serviceName</p><p>unregisterService : Qstring-serviceName</p><p> </p><p> </p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given service with ServiceManager component.</span></p><p><span class="T1">3. On Success of registerService , Service_Manager_Agent will get the API version number for a given service and it will compare the default value with acquired value.</span></p><p><span class="T1">4.From step-3, if both the values are not same then  step- 5 will be continued otherwise the agent will expect another value which is not equal to default value.</span></p><p><span class="T1">5. Service_Manager_Agent will set the API version number for a given service.</span></p><p><span class="T1">6. Service_Manager_Agent will get the API version number for a given service.</span></p><p><span class="T1">7.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">8. Service_Manager_Agent will compare both API  version number and return SUCCESS/FAILURE status.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Compare the API version number with the new API version number.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_SetAPIVersion</p><p>3.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_RegisterForEvents test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_9</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager -  Register and DeRegister events for a given services.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce8"><p>none</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>bool unregisterEvents(ServiceListener* listener)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring - serviceName</p><p>RegisterForEvents : Qlist&lt;QString&gt; - eventNames, ServiceListener* - listener </p><p>UnregisterEvents : ServiceListener* - listener</p><p>unregisterService : Qstring-serviceName</p><p> </p><p> </p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent register event for a given service.</p><p><span class="T1">4. Service_Manager_Agent Deregister event for a given service.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will check both API's return values and return SUCCESS/FAILURE status.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_RegisterForEvents</p><p>2.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_DisplaySetting_SetZoomSettings</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_10</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Get and Set Zoom settings of Display setting service</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>QString getZoomSetting(QString videoDisplay)</p><p>void setZoomSetting(QString videoDisplay, QString zoomLevel)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService<span class="T1"> : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T1">GetGlobalService: const Qstring – serviceName</span></p><p><span class="T1">CallMethod : const QString&amp; method ,const ServiceParams&amp; params.</span></p><p><span class="T1">Method= METHOD_DISPLAY_SETTINGS_GET_ZOOM_SETTING</span></p><p><span class="T1">Params= </span></p><p><span class="T1">GetZoomSetting : QString - videoDisplay</span></p><p><span class="T1">SetZoomSetting : QString  -videoDisplay, QString – zoomLevel</span></p><p><span class="T1">unregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given Displaysettings service with ServiceManager component.</span></p><p><span class="T1">3. On Success of registerService , Service_Manager_Agent will get the Zoom setting for a given service and it will compare the default value with acquired value.</span></p><p><span class="T1">4.From step-3, if both the values are not same then  step- 5 will be continued otherwise the agent will expect another value which is not equal to default value.</span></p><p><span class="T1">5.Service_Manager_Agent will set Zoom settings for DisplaySettings service.</span></p><p><span class="T1">6. Service_Manager_Agent will get Zoom settings for DisplaySettings service.</span></p><p><span class="T1">7.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">8. Service_Manager_Agent will compare both zoom settings and return SUCCESS/FAILURE status.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of APIs for success status.</span></p><p><span class="T1"/></p><p><span class="T1">Checkpoint 2. Compare the Zoom settings with new value.</span></p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_DisplaySetting_SetZoomSettings</p><p>3.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>No Implementation in service source code.</p><p>Function present in header file and also in source with empty function body.</p><p> </p><p>This scripting has not developed as this functionality has not been implemented by Service Manager module.</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_SetResolution test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_11</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager –  Get and set current resolution of Displaysettings service</p><p> </p><p> </p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>QString getCurrentResolution(QString videoDisplay)</p><p>void setCurrentResolution(QString videoDisplay, QString resolution)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService<span class="T1"> : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T1">GetGlobalService: const Qstring – serviceName</span></p><p><span class="T1">GetCurrentResolution : QString - videoDisplay</span></p><p><span class="T1">SetCurrentResolution : QString – videoDisplay ,QString - resolution</span></p><p><span class="T1">unregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given Displaysettings service with ServiceManager component.</span></p><p><span class="T1">3. On Success of registerService , Service_Manager_Agent will get the resolution for a given service and it will compare the default value with acquired value.</span></p><p><span class="T1">4.From step-3, if both the values are not same then  step- 5 will be continued otherwise the agent will expect another value which is not equal to default value.</span></p><p><span class="T1">5.Service_Manager_Agent will set resolution for DisplaySettings service.</span></p><p><span class="T1">6. Service_Manager_Agent will get resolution for DisplaySettings service.</span></p><p><span class="T1">7. Service_Manager_Agent will compare both resolution and return SUCCESS/FAILURE status.</span></p><p><span class="T1">8.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of APIs for success status.</span></p><p><span class="T1"/></p><p><span class="T1">Checkpoint 2. Compare the resolution with new value.</span></p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_DisplaySetting_SetCurrentResolution.</p><p>3.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_EnableVpop test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_12</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking the status of VPOP(Enabled / Disabled)</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>CallMethod : const QString – METHOD_HN_IS_VPOP_ENABLED ,</p><p>const ServiceParams – Null</p><p>CallMethod : const QString - METHOD_HN_SET_VPOP_ENABLED ,const ServiceParams - bool</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given homenetworking service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService , Service_Manager_Agent will enable VPOP for homenetworking service.</span></p><p><span class="T1">4. Service_Manager_Agent will check VPOP enable for homenetworking service.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will check VPOP enable status and return SUCCESS/FAILURE status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Compare the VPOP status before and after enabling.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_HN_EnableVPOP</p><p>3.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>This scripting has not developed as this functionality has not been implemented by Service Manager module.</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_EnableMdvr test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_13</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking for MDVR support(Enabled/Disabled).</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>CallMethod : const QString -  METHOD_HN_IS_MDVR_ENABLED,const ServiceParams&amp; - Null</p><p>CallMethod : const QString- METHOD_HN_SET_MDVR_ENABLED, const ServiceParams - bool </p><p>unregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given homenetworking service with ServiceManager component. </span></p><p><span class="T1">3.On Success of registerService , Service_Manager_Agent will enable MDVR for homenetworking service.</span></p><p><span class="T1">4. Service_Manager_Agent will check MDVR enable for homenetworking service.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will check MDVR enable status and return SUCCESS/FAILURE status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Compare the MDVR status before and after enabling.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_HN_EnableMDVR</p><p>3.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>This scripting has not developed as this functionality has not been implemented by Service Manager module.</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_SetDeviceName test</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_14</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Get and Set DeviceName.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>CallMethod : const QString&amp; -  METHOD_HN_GET_DEVICE_NAME,const ServiceParams - Null</p><p>CallMethod : const QString&amp; - METHOD_HN_SET_DEVICE_NAME,const ServiceParams - “Device1234”</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given homenetworking service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService , Service_Manager_Agent will set device name for homenetworking service.</span></p><p><span class="T1">4.Service_Manager_Agent will get device name for homenetworking service.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will compare both device name and return SUCCESS/FAILURE status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Compare the device name with the new device name.</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_HN_SetDeviceName</p><p>3.TestMgr_SM_UnRegisterService</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>This scripting has not developed as this functionality has not been implemented by Service Manager module.</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_RegisterService_All</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_15</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Check registering all available services ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::registerService</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3. On Success of registerService ,Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>4. Service_Manager_Agent will return SUCCESS/FAILURE status based on the return value of “unregisterService” API.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_UnRegisterService_All</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_16</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to unregister all available services ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::unregisterService</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. Service_Manager_Agent will deregister a given service from ServiceManager component without registering</p><p>3. Service_Manager_Agent will return SUCCESS/FAILURE status based on the return value of “unregisterService” API.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_DoesServiceExist_All</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_17</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to check if a service exists on all available services ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::doesServiceExist</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3. On Success of registerService ,Service_Manager_Agent will check for the service registration status with ServiceManager.</p><p>4. Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>5. Service_Manager_Agent will return SUCCESS/FAILURE status based on the return value of APIs.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_DoesServiceExist</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_GetGlobalService_All</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_18</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to get global service on all available services ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getGlobalService</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1.TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3. On Success of registerService , Service_Manager_Agent will get an instance of a given service.</p><p>4.Service_Manager_Agent will get the name of the service and compare with the queried service.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6.Service_Manager_Agent will return SUCCESS/FAILURE status based on API's return value and step4 .</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_GetGlobalService</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_SetApiVersion_All</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_19</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to setApiVersionNumber/getApiVersionNumber on all available services ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>Service::setApiVersionNumber</p><p>Service::getApiVersionNumber </p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("deviceSettingService", "screenCaptureService", "WebSocketService")</p><p>interger apiVersion (1-1000)</p><p> </p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3. On Success of registerService , Service_Manager_Agent will get the API version number for a given service and it will compare the default value with acquired value.</p><p>4.From step-3, if both the values are not same then step- 5 will be continued otherwise the agent will expect another value which is not equal to default value.</p><p>5. Service_Manager_Agent will set the API version number for a given service.</p><p>6. Service_Manager_Agent will get the API version number for a given service.</p><p>7.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>8. Service_Manager_Agent will compare both API version number and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_SetAPIVersion</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_ScreenCapture_EventUpload</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_20</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to registerForEvents/unregisterEvents all available events ("uploadComplete") for service "screenCaptureService"</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>Service::registerForEvents</p><p>Service::UnregisterEvents</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("screenCaptureService")</p><p>string event_name ("uploadComplete")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent register event for a given service.</p><p>4. Service_Manager_Agent Deregister event for a given service.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. Service_Manager_Agent will check both API's return values and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_RegisterForEvents</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_WebSocket_EventsAll</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_21</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to registerForEvents/unregisterEvents all available events ("onOpen","onError","onClose","onMessage") for service "WebSocketService"</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>Service::registerForEvents</p><p>Service::UnregisterEvents</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("WebSocketService")</p><p>string event_name ("onOpen","onError","onClose","onMessage")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent register event for a given service.</p><p>4. Service_Manager_Agent Deregister event for a given service.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. Service_Manager_Agent will check both API's return values and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_RegisterForEvents</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_GetSetting_All</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_22</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to get settings for all available services ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getSetting</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1.TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3. On Success of registerService , Service_Manager_Agent will get an instance of a given service using service name.</p><p>4.Service_Manager_Agent will get the setting of the service.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6.Service_Manager_Agent will return SUCCESS/FAILURE status based on API's return value and step4 .</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_GetSetting</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_CreateService_All</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_23</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to create all available services ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::doesServiceExist</p><p>ServiceManager::createService</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1.TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3. On Success of registerService , Service_Manager_Agent will create an instance of a given service using service name.</p><p>4.Service_Manager_Agent will delete the instance of the service.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6.Service_Manager_Agent will return SUCCESS/FAILURE status based on API's return value and step4 .</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_CreateService</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_Services_GetName_All</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_24</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>Script to get name of all available services ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getGlobalService</p><p>Service::getName</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string service_name ("deviceSettingService", "screenCaptureService", "WebSocketService")</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1.TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given service with ServiceManager component.</p><p>3. On Success of registerService , Service_Manager_Agent will get an instance of a given service.</p><p>4.Service_Manager_Agent will get the name of the service and compare with the queried service name.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6.Service_Manager_Agent will return SUCCESS/FAILURE status based on API's return value and step4 .</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_Services_GetName</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_ScreenCapture_Upload</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_25</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>To verify upload on screenCaptureService</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getGlobalService</p><p>ScreenCaptureService::callMethod("uploadScreenCapture")</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>string url</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register ScreenCaptureService with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent will get url and execute screencaptureserice upload callmethod.</p><p>4.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>5. Service_Manager_Agent will check upload status and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_ScreenCapture_Upload</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_DeviceSetting_GetDeviceInfo</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_26</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>To verify get device info on deviceSettingService</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getGlobalService</p><p>DeviceSettingService::callMethod("getDeviceInfo")</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DeviceSettingService with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent will get stb mac address info from DeviceSettingService getDeviceInfo callMethod.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. Service_Manager_Agent will check getdeviceinfo status and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_DeviceSetting_GetDeviceInfo</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_WebSocket_GetUrl</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_27</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>To verify get url on WebSocketService</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getGlobalService</p><p>WebSocketService::requestUrl</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DeviceSettingService with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent will get Url address info from WebSocketService requestUrl method.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. Service_Manager_Agent will check requestUrl status and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_WebSocket_GetUrl</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_WebSocket_GetReadyState</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_28</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>To verify get ready state on WebSocketService</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getGlobalService</p><p>WebSocketService::readyState</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DeviceSettingService with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent will get readyState info from WebSocketService readyState method.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. Service_Manager_Agent will check getdeviceinfo status and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_WebSocket_GetReadyState</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_WebSocket_GetBufferedAmount</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_29</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>To verify get buffered amount on WebSocketService</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getGlobalService</p><p>WebSocketService::bufferedAmount</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DeviceSettingService with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent will get buffered amount info from WebSocketService bufferedAmount method.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. Service_Manager_Agent will check get buggered amount status and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_WebSocket_GetBufferedAmount</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce3"><p>SM_WebSocket_GetProtocol</p></td><td style="text-align:left;width:197.66pt; " class="ce6"><p>CT_Service Manager_30</p></td><td style="text-align:left;width:120.61pt; " class="ce3"><p>To verify get protocol on WebSocketService</p></td><td style="text-align:left;width:82.54pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:127.81pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce3"><p>ServiceManager::getGlobalService</p><p>WebSocketService::protocol</p></td><td style="text-align:left;width:217.45pt; " class="ce3"><p>None</p></td><td style="text-align:left;width:520.64pt; " class="ce3"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DeviceSettingService with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent will get protocol info from WebSocketService protocol method.</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. Service_Manager_Agent will check getprotocol status and return SUCCESS/FAILURE status.</p></td><td style="text-align:left;width:142.84pt; " class="ce3"><p>Checkpoint 1.Check the return value of APIs for success status.</p></td><td style="text-align:left;width:50.8pt; " class="ce3"><p>High </p></td><td style="text-align:left;width:114.29pt; " class="ce3"><p>libservicemanagerstub.so</p><p>1.TestMgr_SM_RegisterService</p><p>2.TestMgr_SM_WebSocket_GetProtocol</p><p>3.TestMgr_SM_UnRegisterService</p></td><td style="text-align:left;width:49.21pt; " class="ce3"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_GetDefault_CecSupport</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_31</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking for CEC support default value (Enabled / Disabled). Default value: false(Disabled)</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool getEnabled()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>getEnabled : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will check for hdmicec service support fetch default value.</span></p><p><span class="T1">4.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">5. Service_Manager_Agent will compare the default status with current status returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the default status with current status returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_GetDefaultDeviceName_CecEnabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_32</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Fetching the default name of  CEC device after enabling CEC. Default name: "STB"</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>bool getName()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will check default name for hdmicec device.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will compare the default name with current name returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the default name with current name returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_GetDefaultDeviceName_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_33</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Fetching the default name of  CEC device after disabling CEC. Default name: "STB"</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool false)</p><p>bool getName()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disabling cec service.</span></p><p><span class="T1">4. On Success of disabling cec, Service_Manager_Agent will check default name for hdmicec device.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will compare the default name with current name returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the default name with current name returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_GetDefaultName_DisableCec changed to SM_HdmiCec_GetDefaultDeviceName_CecDisabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_NoHDMIDeviceTest_CecEnabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_34</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking the number of cec devices connected after enabling CEC. Default value: 0 (If no devices connected)</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool setEnabled(bool true)</p><p>bool getConnectedDevices()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>getConnectedDevices: None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, </span></p><p><span class="T1"> Service_Manager_Agent will check number of  hdmicec device connected.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will compare the count = 0 with current count returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the number of devices connected should be 0.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_GetNumOfDevicesConnected_CecEnabled changed to SM_HdmiCec_NoHDMIDeviceTest_CecEnabled during M-29 release.</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_NoHDMIDeviceTest_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_35</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking the number of cec devices connected after disabling CEC. Default value: 0 (If no devices connected)</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool setEnabled(bool false)</p><p>bool getConnectedDevices()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>getConnectedDevices: None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of disabling cec, </span></p><p><span class="T1"> Service_Manager_Agent will check number of  hdmicec device connected.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will compare the count = 0 with current count returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the number of devices connected should be 0.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_GetNumOfDevicesConnected_CecDisabled changed to SM_HdmiCec_NoHDMIDeviceTest_CecDisabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_EnableAndDisable_CecSupport</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_36</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Enabling and disabling the CEC support (Enabled / Disabled). </p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>bool getEnabled()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool - true</p><p>getEnabled : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service by setting true.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will check status by fetching the status.</span></p><p><span class="T1">5. On Success of getting the status, Service_Manager_Agent will disable cec service by setting false.</span></p><p><span class="T1">6. On Success of disabling cec, Service_Manager_Agent will check status by fetching the status.</span></p><p><span class="T1">7.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">8. Service_Manager_Agent will compare the status set and with current status returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the status set with current status returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_SetName_CecEnabled </p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_37</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Setting the STB device name and fetch the name after enabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void setName(Qstring name)</p><p>bool getName()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>setName: Qstring name</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will set the name for CEC device.</span></p><p><span class="T1">5. On Success of setting the name, Service_Manager_Agent will get the name of CEC device that is been set.</span></p><p><span class="T1">6.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">7. Service_Manager_Agent will compare the name set with current name returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the name set with current name returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_EnableCec_SetGetDeviceName changed to SM_HdmiCec_SetName_CecEnabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_SetSpecialCharName_CecEnabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_38</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Setting the STB device name with special characters and numbers as name and fetch the name set after enabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void setName(Qstring name)</p><p>bool getName()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>setName: Qstring name</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will set the name with special characters and numbers for CEC device.</span></p><p><span class="T1">5. On Success of setting the name, Service_Manager_Agent will get the name of CEC device that is been set.</span></p><p><span class="T1">6.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">7. Service_Manager_Agent will compare the name set with current name returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the name set with current name returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p> SM_HdmiCec_EnableCec_SetGetSpecialChar_DevName changed to during M-29 release </p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_SetName_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_39</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Setting the STB device name and fetch the name after disabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool false)</p><p>void setName(Qstring name)</p><p>bool getName()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>setName: Qstring name</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of disabling cec, Service_Manager_Agent will set the name for CEC device.</span></p><p><span class="T1">5. On Success of setting the name, Service_Manager_Agent will get the name of CEC device that is been set.</span></p><p><span class="T1">6.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">7. Service_Manager_Agent will compare the name set with current name returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the name set with current name returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_DisableCec_SetGetDeviceName changed to SM_HdmiCec_SetName_CecDisabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_SendMsgGetCECVersion_CecEnabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_40</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Send message to the STB device with enabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void sendMessage(Qstring message)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>sendMessage: Qstring message</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will send message for a CEC device.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_EnableCec_SendMsg changed to SM_HdmiCec_SendMsgGetCECVersion_CecEnabled during M-29 release </p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_SendMsgGetCECVersion_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_41</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Send message to the STB device without enabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool false)</p><p>void sendMessage(Qstring message)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>sendMessage: Qstring message</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of disabling cec, Service_Manager_Agent will send message for a CEC device.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_DisableCec_SendMsg cahnged to SM_HdmiCec_SendMsgGetCECVersion_CecDisabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_Stress_SendMsg_CecEnabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_42</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Send message to the STB device multiple times (5 times) with enabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void sendMessage(Qstring message)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>sendMessage: Qstring message</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will send message for a CEC device continues 5 times.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_EnableCec_SendMsgFiveTimes chnged to SM_HdmiCec_Stress_SendMsg_CecEnabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_Stress_SendMsg_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_43</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Send message to the STB device multiple times (5 times) with disabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool false)</p><p>void sendMessage(Qstring message)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>sendMessage: Qstring message</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of disabling cec, Service_Manager_Agent will send message for a CEC device continues 5 times.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_DisableCec_SendMsgFiveTimes Changed to SM_HdmiCec_Stress_SendMsg_CecDisabled during M-29 release </p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_Stress_SetName_CecEnabled </p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_44</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Setting the STB device name and fetch the name multiple times (5 times) after enabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void setName(Qstring name)</p><p>bool getName()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>setName: Qstring name</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will set the name for CEC device 5 times.</span></p><p><span class="T1">5. On Success of setting the name, Service_Manager_Agent will get the name of CEC device that is been set.</span></p><p><span class="T1">6.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">7. Service_Manager_Agent will compare the name set with current name returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the name set with current name returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_EnableCec_SetName_FiveTimes changed to SM_HdmiCec_Stress_SetName_CecEnabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_Stress_SetName_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_45</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Setting the STB device name and fetch the name multiple times (5 times) after disabling CEC.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"> </td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool false)</p><p>void setName(Qstring name)</p><p>bool getName()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>setName: Qstring name</p><p>getName : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of disabling cec, Service_Manager_Agent will set the name for CEC device 5 times.</span></p><p><span class="T1">5. On Success of setting the name, Service_Manager_Agent will get the name of CEC device that is been set.</span></p><p><span class="T1">6.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">7. Service_Manager_Agent will compare the name set with current name returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the name set with current name returned.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>Yes</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_DisableCec_SetName_FiveTimes changed to SM_HdmiCec_Stress_SetName_CecDisabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_SendAbortMsg_CecEnabled </p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_46</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Send a random message and receive message to and from the cec device after enabling the cec.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void sendMessage(Qstring message)</p><p>void onMessage( QString message )</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>sendMessage: Qstring message</p><p>onMessage: Qstring message</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will send message for a CEC device.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent should recieve the message as response from the device and when onMessage event will be called.</span></p><p><span class="T1">6 On Success of onMessage, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_EnableCec_SendReceiveMsg changed to SM_HdmiCec_SendAbortMsg_CecEnabled during M-29 release </p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_SendAbortMsg_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_47</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Send a random message and receive message to and from the cec device after disabling the cec.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void sendMessage(Qstring message)</p><p>void onMessage( QString message )</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>sendMessage: Qstring message</p><p>onMessage: Qstring message</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of disabling cec, Service_Manager_Agent will send message for a CEC device.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent should recieve the message as response from the device and when onMessage event will be called.</span></p><p><span class="T1">6 On Success of onMessage, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_DisableCec_SendReceiveMsg changed to SM_HdmiCec_SendAbortMsg_CecDisabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_SendMsgGetPowerStatus_CecEnabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_48</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Send a message HEX command (30 8F) to check the device power status and receive message from the cec device ( 03 90 00(off) or 03 90 01(on)) after enabling the cec.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected and power state should be ON.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void sendMessage(Qstring message)</p><p>void onMessage( QString message )</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>sendMessage: Qstring message</p><p>onMessage: Qstring message</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will send message (30 8F) for a CEC device.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent should recieve the message (03 90 00 or 03 90 01 ) as response from the device and when onMessage event will be called.</span></p><p><span class="T1">6 On Success of onMessage, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p><p>Checkpoint 3.Compare the power status with the values (039000 -&gt; on, 039001 -&gt; off)  </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_EnableCec_SendReceivePowerState changed to SM_HdmiCec_SendMsgGetPowerStatus_CecDisabled during M-29 release.</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_DisableCec_SendReceivePowerState</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_49</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Send a message HEX command (30 8F) to check the device power status and receive message from the cec device ( 03 90 00(off) or 03 90 01(on)) after disabling the cec.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected and power state should be ON.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool false)</p><p>void sendMessage(Qstring message)</p><p>void onMessage( QString message )</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>sendMessage: Qstring message</p><p>onMessage: Qstring message</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of disabling cec, Service_Manager_Agent will send message (30 8F) for a CEC device.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent should recieve the message (03 90 00 or 03 90 01 ) as response from the device and when onMessage event will be called.</span></p><p><span class="T1">6 On Success of onMessage, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p><p>Checkpoint 3.Compare the power status with the values (039000 -&gt; on, 039001 -&gt; off)  </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_DisableCec_SendReceivePowerState changed to SM_HdmiCec_SendMsgGetPowerStatus_CecDisabled during M-29 release </p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_EnableCecSendMsg_DisableCecSendMsg</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_50</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Enable cec and Send a message, then disable cec and send a message to the device connected.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>void sendMessage(Qstring message)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>sendMessage: Qstring message</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, Service_Manager_Agent will send message for a CEC device.</span></p><p><span class="T1">5. On Success of sending the message to the device, Service_Manager_Agent should disable cec service and send a message.</span></p><p><span class="T1">6 On Success of sending a message, Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Check for the message pattern for message sent in cec.txt.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_GetNumOfDevicesConnected_CecEnabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>cd -</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking the number of cec devices connected after enabling CEC. Atleast one hdmicec device is connected.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool setEnabled(bool true)</p><p>bool getConnectedDevices()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>getConnectedDevices: None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will enable cec service.</span></p><p><span class="T1">4. On Success of enabling cec, </span></p><p><span class="T1"> Service_Manager_Agent will check number of  hdmicec device connected.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will compare the count &gt; 0 with current count returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the number of devices connected should be greater than 0.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_GetNumOfDevicesConnected_CecEnabled_AtLeastOne changed to SM_HdmiCec_GetNumOfDevicesConnected_CecEnabled during M-29 release</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_GetNumOfDevicesConnected_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_52</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking the number of cec devices connected after disabling CEC. Atleast one hdmicec device is connected.</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool setEnabled(bool false)</p><p>bool getConnectedDevices()</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool false</p><p>getConnectedDevices: None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p><span class="T1">2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</span></p><p><span class="T1">3.On Success of registerService, Service_Manager_Agent will disable cec service.</span></p><p><span class="T1">4. On Success of disabling cec, </span></p><p><span class="T1"> Service_Manager_Agent will check number of  hdmicec device connected.</span></p><p><span class="T1">5.Service_Manager_Agent will deregister a given service from ServiceManager component.</span></p><p><span class="T1">6. Service_Manager_Agent will compare the count &gt; 0 with current count returned.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2.Compare the number of devices connected should be greater than 0.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>SM_HdmiCec_GetNumOfDevicesConnected_CecDisabled_AtLeastOne change dto SM_HdmiCec_GetNumOfDevicesConnected_CecDisabled  during M-29 release </p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_Persist_CecEnabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_53</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking whether HdmiCecService::getEnabled() returns true without enabling cec, but obtained from persisted status</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>bool getEnabled()</p><p>bool unregisterService(const QString&amp; )</p><p>bool getEnabled()</p><p> </p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>getEnabled : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</p><p>3.On Success of registerService, Service_Manager_Agent will enable cec service.</p><p>4. On Success of enabling cec, </p><p> Service_Manager_Agent will check the status of cec service</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. after deregistering Service_Manager_Agent will check the status of cec service</p><p> </p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Checking the cec service status persists even after deregister the service</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce3"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce2"><p>SM_HdmiCec_Persist_CecDisabled</p></td><td style="text-align:left;width:197.66pt; " class="ce2"><p>CT_Service Manager_54</p></td><td style="text-align:left;width:120.61pt; " class="ce2"><p>Service Manager – Checking whether HdmiCecService::getEnabled() returns false obtained from persisted status</p></td><td style="text-align:left;width:82.54pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce2"><p>XG1-V3/ XI-3</p></td><td style="text-align:left;width:127.81pt; " class="ce2"><p>Atleast one HDMI device must be connected.</p></td><td style="text-align:left;width:288.91pt; " class="ce2"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>void setEnabled(bool true)</p><p>bool getEnabled()</p><p>void setEnabled(bool false)</p><p>bool getEnabled()</p><p>bool unregisterService(const QString&amp; )</p><p>bool getEnabled()</p><p> </p></td><td style="text-align:left;width:217.45pt; " class="ce2"><p>registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</p><p>GetGlobalService: const Qstring – serviceName</p><p>setEnabled: bool true</p><p>getEnabled : None</p><p>setEnabled: bool false</p><p>getEnabled : None</p><p>UnregisterService : Qstring-serviceName</p></td><td style="text-align:left;width:520.64pt; " class="ce2"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register a given hdmicec service with ServiceManager component.</p><p>3.On Success of registerService, Service_Manager_Agent will enable cec service.</p><p>4. On Success of enabling cec, </p><p> Service_Manager_Agent will check the status of cec service</p><p>5.After disbaling cec service Service_Manager_Agent will check the status of cec service</p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p>6. after deregistering Service_Manager_Agent will check the status of cec service</p><p> </p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce2"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Checking the cec service status persists even after deregister the service</p></td><td style="text-align:left;width:50.8pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce2"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce3"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce3"><p>none</p></td><td style="text-align:left;width:50.8pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_AVInputService_AVInputActiveEvent_1259</p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_1259_1</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test AVInputService's onAVInputActive event using IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register AVInputService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event onAVInputActive.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted with isPortConnected=true</p><p>7. Check if the handler registered for onAVInputActive is getting invoked</p><p>8.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for onAVInputActive is getting invoked</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M38</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce14"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_AVInputService_AVInputInactiveEvent_1259</p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_1259_2</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test AVInputService's onAVInputInactive event using IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register AVInputService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event onAVInputInactive.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted with isPortConnected=false</p><p>7. Check if the handler registered for onAVInputInactive is getting invoked</p><p>8.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for onAVInputInactive is getting invoked</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M39</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce14"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_AVInputService_AVInputActive_BackToBack_1259</p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_1259_3</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test multiple invokation AVInputService's onAVInputActive event using IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register AVInputService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event onAVInputInactive.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted</p><p>7. Check if the handler registered for onAVInputActive is getting invoked with isPortConnected=true</p><p>8. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted</p><p>9.Check if the handler registered for onAVInputActive is getting invoked with isPortConnected=true</p><p>10.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for onAVInputActive is getting invoked</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M40</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce14"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_AVInputService_AVInputInactive_BackToBack_1259</p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_1259_4</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test multiple invokation AVInputService's onAVInputI nactive event using IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register AVInputService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event onAVInputInactive.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted with isPortConnected=false</p><p>7. Check if the handler registered for onAVInputInactive is getting invoked</p><p>8. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted with isPortConnected=false</p><p>9.Check if the handler registered for onAVInputInactive is getting invoked</p><p>10.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for onAVInputInactive is getting invoked</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M41</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_AVInputService_AVInputActiveInactive_EventSequence_1259</p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_1259_5</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test sequential invokation of AVInputService's onAVInputActive and  onAVInputInactive event using IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register AVInputService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event onAVInputInactive.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted with isPortConnected=true</p><p>7. Check if the handler registered for onAVInputActive is getting invoked</p><p>8. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted with isPortConnected=false</p><p>9.Check if the handler registered for onAVInputInactive is getting invoked</p><p>10.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for onAVInputActive is getting invoked</p><p> </p><p>Check if the handler registered for onAVInputInactive is getting invoked</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M42</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_AVInputService_AVInputInactiveActive_EventSequence_1259</p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_1259_6</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test sequential invokation of AVInputService's onAVInputInactive and  onAVInputActive event using IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register AVInputService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event onAVInputInactive.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted with isPortConnected=false</p><p>7. Check if the handler registered for onAVInputInactive is getting invoked</p><p>8. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_IN_HOTPLUG is broadcasted with isPortConnected=true</p><p>9.Check if the handler registered for onAVInputActive is getting invoked</p><p>10.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for onAVInputInactive is getting invoked</p><p> </p><p>Check if the handler registered for onAVInputActive is getting invoked</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M43</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_ConnectedAudioPort_14319_1 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_1</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Checks DisplaySettingService::getConnectedAudioPorts() output for a non-null value, as spdif port is always considered connected</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "getConnectedAudioPorts" ,const ServiceParams - bool</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , Service_Manager_Agent will get connected port list from DisplaySettingService getConnectedAudioPorts callMethod.</p><p>5. Service_Manager_Agent will check getConnectedAudioPorts status and return SUCCESS/FAILURE status.</p><p>6.Service_Manager_Agent will deregister a given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p>Checkpoint 2. Check the json returned as connected port list</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SupportedAudioPort_14319_2 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_2</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Checks DisplaySettingService::getSupportedAudioPorts() output for a non-null value</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                  CallMethod : const QString - "getSupportedAudioPorts" ,const ServiceParams - bool                            </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSupportedAudioPorts callMethod</p><p>4.Service_Manager_Agent will check getSupportedAudioPortst status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_GetSoundMode_SPDIF_14319_3 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_3</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Using DisplaySettingService::getSoundMode() checks sound mode of SPDIF port</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "getSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSoundMode callMethod iwth SPDIF as parameter</p><p>4.Service_Manager_Agent will check getSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_GetSupportedAudioMode_SPDIF_14319_4 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_4</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Using DisplaySettingService::getSupportedAudioMode() Checks supported audio modes of SPDIF port</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                    CallMethod : const QString - "getSupportedAudioMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSupportedAudioMode callMethod with SPDIF as parameter</p><p>4.Service_Manager_Agent will check getSupportedAudioMode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_GetSupportedAudioMode_WithHDMI_14319_5 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_5</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Using DisplaySettingService::getSupportedAudioMode(), Checks supported audio modes of HDMI port when port is connected</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should be connected to a TV</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                                               CallMethod : const QString - "getSupportedAudioModes" ,const ServiceParams - bool</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSupportedAudioMode callMethod with HDMI0 as parameter</p><p>4.Service_Manager_Agent will check getSupportedAudioMode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_GetSupportedAudioMode_WithoutHDMI_14319_6 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_6</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Using DisplaySettingService::getSupportedAudioMode(HDMI0), Checks supported audio modes of HDMI port when port is not connected. Output should be same as getSupportedAudioModes()</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should not be connected </p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                                               CallMethod : const QString - "getSupportedAudioModes" ,const ServiceParams - bool</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSupportedAudioMode callMethod with HDMI0 as parameter</p><p>4.Service_Manager_Agent will check getSupportedAudioMode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_GetSupportedAudioMode_ParamNone_14319_7 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_7</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Testing DisplaySettingService::getSupportedAudioMode()</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                                               CallMethod : const QString - "getSupportedAudioModes" ,const ServiceParams - bool</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSupportedAudioMode callMethod with no parameter</p><p>4.Service_Manager_Agent will check getSupportedAudioMode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_GetSoundMode_HDMI_14319_8 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_8</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Using DisplaySettingService::getSoundMode() checks sound mode of HDMI port</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "getSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSoundMode callMethod iwth HDMI as parameter</p><p>4.Service_Manager_Agent will check getSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_SPDIF_ValidMode_14319_9 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_9</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Using DisplaySettingService::setSoundMode() sets sound mode of SPDIF port</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod iwth SPDIFI as parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_SPDIF_InvalidMode_14319_10 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_10</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Using DisplaySettingService::setSoundMode() sets sound mode of SPDIF port to an incompatible mode</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod iwth SPDIF as parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_NoHDMI_ValidMode_14319_11 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_11</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::setSoundMode() on unconnected HDMI port with a valid audio mode</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should not be connected </p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod iwth HDMI as parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_NoHDMI_InvalidMode_14319_12 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_12</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::setSoundMode() on unconnected HDMI port with a invalid audio mode</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should not be connected </p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod iwth HDMI as parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_GetSoundMode_None_WithoutHDMI_14319_13 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_13</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::getSoundMode()  with no parameter and HDMI disconnected. Output should be same as getSoundMode(SPDIF0)</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should not be connected </p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "getSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSoundMode callMethod with no parameter</p><p>4.Service_Manager_Agent will check getSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_GetSoundMode_None_WithHDMI_14319_14 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_14</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::getSoundMode()  with no parameter and HDMI connected. Output should be same as getSoundMode(HDMI0)</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should be connected to a TV</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "getSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getSoundMode callMethod with no parameter</p><p>4.Service_Manager_Agent will check getSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_WithHDMI_ValidMode_14319_15 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_15</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::setSoundMode()  on a connected HDMI port with a valid audio mode</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should be connected to a TV</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod with HDMI as parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_WithHDMI_InValidMode_14319_16 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_16</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::setSoundMode()  on a connected HDMI port with a invalid audio mode</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should be connected to a TV</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod with HDMI as parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_None_WithHDMI_14319_17 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_17</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::setSoundMode()   with no parameters and hdmi connected. Soundmode of connected ports should change</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should be connected to a TV</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod with no parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_None_WithoutHDMI_14319_18 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_18</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::setSoundMode()   with no parameters and HDMI not connected. Soundmode of connected ports should change</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should not be connected </p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod with no parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_SetSoundMode_None_InvalidMode_14319_19 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_19</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager –Test DisplaySettingService::setSoundMode()   with no port specified and with an invalid audio mode. Audiomode of connected port should not change</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Negative</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "setSoundMode" ,const ServiceParams - bool                             </span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService setSoundMode callMethod with no parameter</p><p>4.Service_Manager_Agent will check setSoundmode status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_ConnectedAudioPort_WithoutHDMI_14319_20 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_20</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Tests DisplaySettingService::getConnectedAudioPorts() without HDMI port connected</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should not be connected </p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "getConnectedAudioPorts" ,const ServiceParams - bool</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getConnectedAudioPort callMethod </p><p>4.Service_Manager_Agent will check getConnectedAudioPort status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_ConnectedAudioPort_WithHDMI_14319_21 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_13419_21</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>Service Manager – Tests DisplaySettingService::getConnectedAudioPorts() with HDMI port connected</p></td><td style="text-align:left;width:82.54pt; " class="ce7"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>HDMI out of STB should be connected to a TV</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName) virtual ServiceParams callMethod(const QString&amp; method,const ServiceParams&amp; params)</p><p>bool unregisterService(const QString&amp; )                                  </p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                CallMethod : const QString - "getConnectedAudioPorts" ,const ServiceParams - bool</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>3.On Success of registerService , calls DisplaySettingService getConnectedAudioPort callMethod </p><p>4.Service_Manager_Agent will check getConnectedAudioPort status and return SUCCESS/FAILURE status. </p><p>5.Service_Manager_Agent will deregister a given service from ServiceManager component.</p><p> </p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Checkpoint 1.Check the return value of APIs for success status.</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M37</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_HDMI_HotplugEvent_Connected_16024_1 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_16024_1</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test DisplaySettingService's connectedVideoDisplaysUpdated event on connecting display device</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event connectedVideoDisplaysUpdated.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted with event =  dsDISPLAY_EVENT_CONNECTED</p><p>7. Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked</p><p>8.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked with connectedVideoDisplays = HDMI0</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M38</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_HDMI_HotplugEvent_Disconnected_16024_2 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_16024_2</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test DisplaySettingService's connectedVideoDisplaysUpdated event on disconnecting display device</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event connectedVideoDisplaysUpdated.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted with event =  dsDISPLAY_EVENT_CONNECTED</p><p>7. Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked</p><p>8.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked with an empty connectedVideoDisplays list</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M38</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_HDMI_HotplugEventConnected_BackToBack_16024_3 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_16024_3</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test multiple invokation DisplaySettingService's connectedVideoDisplaysUpdated event on connecting display device</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce4"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event connectedVideoDisplaysUpdated.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted</p><p>7. Check if the handler registered for onAVInputActive is getting invoked with event =  dsDISPLAY_EVENT_CONNECTED</p><p>8. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted</p><p>9.Check if the handler registered for onAVInputActive is getting invoked with event =  dsDISPLAY_EVENT_CONNECTED</p><p>10.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked with connectedVideoDisplays = HDMI0</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M38</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_HDMI_HotplugEventDisconnected_BackToBack_16024_4 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_16024_4</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test multiple invokation DisplaySettingService's connectedVideoDisplaysUpdated event on disconnecting display device</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event connectedVideoDisplaysUpdated.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted withevent =  dsDISPLAY_EVENT_DISCONNECTED</p><p>7. Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked</p><p>8. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted withevent =  dsDISPLAY_EVENT_DISCONNECTED</p><p>9.Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked</p><p>10.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked with an empty connectedVideoDisplays list</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M38</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_HDMI_HotplugEvents_Sequence_16024_5 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_16024_5</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test sequential invokation of DisplaySettingService's   connectedVideoDisplaysUpdated event on connecting and disconnecting display device</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event connectedVideoDisplaysUpdated.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted with event =  dsDISPLAY_EVENT_CONNECTED</p><p>7. Check if the handler registered for onAVInputActive is getting invoked</p><p>8. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted with event =  dsDISPLAY_EVENT_DISCONNECTED</p><p>9.Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked</p><p>10.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked with connectedVideoDisplays = HDMI0</p><p> </p><p>Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked with an empty connectedVideoDisplays list</p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M38</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce4"><p>SM_DisplaySettings_HDMI_HotplugEvents_Sequence_16024_6 </p></td><td style="text-align:left;width:197.66pt; " class="ce4"><p>CT_16024_6</p></td><td style="text-align:left;width:120.61pt; " class="ce4"><p>To test sequential invokation of DisplaySettingService's   connectedVideoDisplaysUpdated event on disconnecting and connecting display device</p></td><td style="text-align:left;width:82.54pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:138.9pt; " class="ce4"><p>XG1-V3</p></td><td style="text-align:left;width:127.81pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:288.91pt; " class="ce4"><p>bool registerService(const QString&amp; , ServiceStruct )</p><p>Service* getGlobalService(const QString&amp; serviceName)</p><p>bool AbstractService::registerForEvents(QList&lt;QString&gt; eventNames, ServiceListener* listener)</p><p>IARM_Result_t IARM_Bus_RegisterEventHandler(const char *ownerName, IARM_EventId_t eventId, IARM_EventHandler_t handler);</p><p>IARM_Result_t IARM_Bus_BroadcastEvent(const char *ownerName, IARM_EventId_t eventId, void *data, size_t len)</p><p>bool unregisterService(const QString&amp; )</p></td><td style="text-align:left;width:217.45pt; " class="ce9"><p><span class="T2">registerService : Qstring-serviceName, ServiceStruct - serviceStruct (function ptr)</span></p><p><span class="T2">GetGlobalService: const Qstring – serviceName                                registerForEvents : QList&lt;QString&gt; eventNames, ServiceListener* listener</span></p><p><span class="T2">IARM_Bus_BroadcastEvent</span><span class="T3"> : </span><span class="T4">const char* -ownerName, IARM_EventId_t eventId, void *data, size_t length</span></p><p><span class="T2">UnregisterService : Qstring-serviceName</span></p></td><td style="text-align:left;width:520.64pt; " class="ce7"><p>1. TM loads the Service_Manager_Agent via the test agent.</p><p>2. QApplication main event loop is started</p><p>3.Service_Manager_Agent will register DisplaySettingService with ServiceManager component.</p><p>4.On Success of registerService , Service_Manager_Agent will register a handler for the event connectedVideoDisplaysUpdated.</p><p>5.An IARM bus event handler is registered for the iarm event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG.</p><p>6. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted withevent =  dsDISPLAY_EVENT_DISCONNECTED</p><p>7. Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked</p><p>8. Iarm bus event IARM_BUS_DSMGR_EVENT_HDMI_HOTPLUG is broadcasted withevent =  dsDISPLAY_EVENT_CONNECTED</p><p>9.Check if the handler registered for onAVInputActive is getting invoked</p><p>10.Service_Manager_Agent will deregister the given service from ServiceManager component.</p></td><td style="text-align:left;width:142.84pt; " class="ce4"><p>Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked with an empty connectedVideoDisplays list</p><p> </p><p>Check if the handler registered for connectedVideoDisplaysUpdated is getting invoked with connectedVideoDisplays = HDMI0</p><p> </p><p> </p></td><td style="text-align:left;width:50.8pt; " class="ce4"><p>High</p></td><td style="text-align:left;width:114.29pt; " class="ce4"><p>libservicemanagerstub.so</p><p> </p></td><td style="text-align:left;width:49.21pt; " class="ce2"><p>No</p></td><td style="text-align:left;width:134.16pt; " class="ce4"><p>M38</p></td><td style="text-align:left;width:124.61pt; " class="ce2"><p>None</p></td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce5"> </td><td style="text-align:left;width:197.66pt; " class="ce5"> </td><td style="text-align:left;width:120.61pt; " class="ce5"> </td><td style="text-align:left;width:82.54pt; " class="ce5"> </td><td style="text-align:left;width:138.9pt; " class="ce5"> </td><td style="text-align:left;width:127.81pt; " class="ce5"> </td><td style="text-align:left;width:288.91pt; " class="ce5"> </td><td style="text-align:left;width:217.45pt; " class="ce10"> </td><td style="text-align:left;width:520.64pt; " class="ce5"> </td><td style="text-align:left;width:142.84pt; " class="ce5"> </td><td style="text-align:left;width:50.8pt; " class="ce5"> </td><td style="text-align:left;width:114.29pt; " class="ce5"> </td><td style="text-align:left;width:49.21pt; " class="ce5"> </td><td style="text-align:left;width:134.16pt; " class="ce5"> </td><td style="text-align:left;width:124.61pt; " class="ce5"> </td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr><tr class="ro2"><td style="text-align:left;width:388.09pt; " class="ce5"> </td><td style="text-align:left;width:197.66pt; " class="ce5"> </td><td style="text-align:left;width:120.61pt; " class="ce5"> </td><td style="text-align:left;width:82.54pt; " class="ce5"> </td><td style="text-align:left;width:138.9pt; " class="ce5"> </td><td style="text-align:left;width:127.81pt; " class="ce5"> </td><td style="text-align:left;width:288.91pt; " class="ce5"> </td><td style="text-align:left;width:217.45pt; " class="ce10"> </td><td style="text-align:left;width:520.64pt; " class="ce5"> </td><td style="text-align:left;width:142.84pt; " class="ce5"> </td><td style="text-align:left;width:50.8pt; " class="ce5"> </td><td style="text-align:left;width:114.29pt; " class="ce5"> </td><td style="text-align:left;width:49.21pt; " class="ce5"> </td><td style="text-align:left;width:134.16pt; " class="ce5"> </td><td style="text-align:left;width:124.61pt; " class="ce5"> </td><td style="text-align:left;width:50.8pt; " class="ce5"> </td></tr></table></body></html>