<?xml version="1.0" encoding="UTF-8"?>
<!--
 If not stated otherwise in this file or this component's Licenses.txt file the
 following copyright and licenses apply:

 Copyright 2016 RDK Management

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.contributor" content="Nampoothiri, Sreelal (Contractor)"/><meta name="DCTERMS.modified" content="2016-05-27T08:21:54" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.ta2 { writing-mode:lr-tb; }
	.Default { font-family:Arial; padding:2.01pt; }
	.ce1 { background-color:#558ed5; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce10 { background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce11 { background-color:#558ed5; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce12 { padding:2.01pt; font-family:Arial; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce13 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce14 { padding:2.01pt; font-family:Arial; background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce15 { padding:2.01pt; font-family:Arial; vertical-align:middle; text-align:center ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce16 { padding:2.01pt; font-family:Arial; vertical-align:middle; text-align:center ! important; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce17 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce18 { padding:2.01pt; font-family:Arial; background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce19 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce2 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce20 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce21 { background-color:#c0c0c0; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce22 { background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce23 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce24 { padding:2.01pt; font-family:Arial; background-color:#c0c0c0; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce25 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; }
	.ce26 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce27 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0pt; writing-mode:page; }
	.ce28 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:center ! important; }
	.ce29 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce3 { background-color:#c0c0c0; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce30 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce31 { background-color:#ffffff; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce32 { background-color:#c0c0c0; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce33 { padding:2.01pt; font-family:Arial; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce34 { padding:2.01pt; font-family:Arial; background-color:#969696; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce35 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce36 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; text-align:left ! important; }
	.ce37 { padding:2.01pt; font-family:Arial; background-color:#c0c0c0; }
	.ce38 { padding:2.01pt; font-family:Arial; font-size:8pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce39 { padding:2.01pt; font-family:Arial; background-color:#558ed5; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0pt; writing-mode:page; color:#ffffff; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:bold; }
	.ce4 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce40 { padding:2.01pt; font-family:Arial; background-color:#33cccc; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#ffffff; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:bold; }
	.ce41 { padding:2.01pt; font-family:Arial; background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce42 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce43 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; }
	.ce5 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce6 { padding:2.01pt; font-family:Arial; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce7 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce8 { padding:2.01pt; font-family:Arial; background-color:#969696; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce9 { padding:2.01pt; font-family:Arial; }
	.co1 { width:114.15pt; }
	.co10 { width:193.44pt; }
	.co11 { width:256.9pt; }
	.co12 { width:96.69pt; }
	.co13 { width:64.2pt; }
	.co14 { width:50.29pt; }
	.co15 { width:142.7pt; }
	.co16 { width:149.05pt; }
	.co17 { width:117.35pt; }
	.co18 { width:90.4pt; }
	.co19 { width:215.66pt; }
	.co2 { width:140.34pt; }
	.co20 { width:93.54pt; }
	.co21 { width:175.21pt; }
	.co22 { width:84.05pt; }
	.co23 { width:79.31pt; }
	.co24 { width:91.96pt; }
	.co3 { width:77.7pt; }
	.co4 { width:108.6pt; }
	.co5 { width:185.5pt; }
	.co6 { width:127.64pt; }
	.co7 { width:268.75pt; }
	.co8 { width:177.59pt; }
	.co9 { width:63.41pt; }
	.ro1 { height:45.61pt; }
	.ro10 { height:178.5pt; }
	.ro11 { height:165.74pt; }
	.ro12 { height:318.76pt; }
	.ro13 { height:344.24pt; }
	.ro14 { height:325.36pt; }
	.ro15 { height:314.84pt; }
	.ro16 { height:153.01pt; }
	.ro17 { height:272.44pt; }
	.ro18 { height:409.49pt; }
	.ro19 { height:168.75pt; }
	.ro2 { height:188.11pt; }
	.ro20 { height:179.26pt; }
	.ro21 { height:171.01pt; }
	.ro22 { height:170.25pt; }
	.ro23 { height:176.85pt; }
	.ro24 { height:173.85pt; }
	.ro25 { height:175.35pt; }
	.ro26 { height:178.36pt; }
	.ro27 { height:185.1pt; }
	.ro28 { height:177.19pt; }
	.ro29 { height:206.11pt; }
	.ro3 { height:201.4pt; }
	.ro30 { height:166.51pt; }
	.ro31 { height:31.49pt; }
	.ro32 { height:280.49pt; }
	.ro33 { height:229.49pt; }
	.ro34 { height:306pt; }
	.ro35 { height:242.25pt; }
	.ro36 { height:197.86pt; }
	.ro37 { height:177.96pt; }
	.ro38 { height:364.51pt; }
	.ro39 { height:382.51pt; }
	.ro4 { height:223.14pt; }
	.ro40 { height:12.76pt; }
	.ro41 { height:25.54pt; }
	.ro42 { height:395.26pt; }
	.ro43 { height:127.5pt; }
	.ro44 { height:25.51pt; }
	.ro5 { height:409.61pt; }
	.ro6 { height:253.16pt; }
	.ro7 { height:293.24pt; }
	.ro8 { height:255pt; }
	.ro9 { height:204.01pt; }
	.T1 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T10 { font-family:Times New Roman; font-size:12pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.T2 { color:#000000; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; font-family:Arial; }
	.T3 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; text-decoration:underline; font-style:normal; text-shadow:none; }
	.T4 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; font-style:normal; text-shadow:none; text-decoration:none ! important; }
	.T5 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T6 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:underline; font-style:normal; text-shadow:none; }
	.T7 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; font-style:normal; text-shadow:none; text-decoration:none ! important; }
	.T8 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; font-style:normal; text-shadow:none; text-decoration:underline; }
	.T9 { color:#000000; font-size:10pt; font-weight:normal; font-style:normal; text-shadow:none; font-family:Arial; text-decoration:none ! important; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="margin-top:56.69pt; margin-bottom:56.69pt; margin-left:56.69pt; margin-right:56.69pt; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="176"/><col width="216"/><col width="120"/><col width="167"/><col width="216"/><col width="286"/><col width="197"/><col width="414"/><col width="274"/><col width="98"/><col width="298"/><col width="396"/><col width="149"/><col width="99"/><col width="99"/></colgroup><tr class="ro1"><td style="text-align:left;width:114.15pt; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:140.34pt; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:77.7pt; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:108.6pt; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:140.34pt; " class="ce1"><p>API's / Interface Used</p></td><td style="text-align:left;width:185.5pt; " class="ce1"><p>Input Parameters</p><p>(<span class="T3">API name</span><span class="T4">: parameter type – value) / </span></p><p><span class="T5">Interface Input</span></p></td><td style="text-align:left;width:127.64pt; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:268.75pt; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:177.59pt; " class="ce1"><p>Exp Output</p></td><td style="text-align:left;width:63.41pt; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:193.44pt; " class="ce1"><p>Test Stub Interface</p></td><td style="text-align:left;width:256.9pt; " class="ce1"><p>Test script</p></td><td style="text-align:left;width:96.69pt; " class="ce28"><p>Remarks</p></td><td style="text-align:left;width:64.2pt; " class="ce1"><p>Release version</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Joining application with IARMBUS </p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Connect &amp; Disconnect test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_2</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Joining application with IARMBUS where the application is already joined with the IARMBUS.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent will try to register the application which is already registered with the Process group.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Init Negative test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_3</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Checking process registration status with IARMDaemon Manager</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_IsConnected(const char *, int *)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_IsConnected</span><span class="T7"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS IsConnected test</p></td><td style="text-align:left;width:96.69pt; " class="ce30"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_4</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – deregister event handler for removing listener for an event.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> - None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> - None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS unregisterEvt Handler test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_5</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – deregister event handler without registering event handler.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce2"><p> </p><p><span class="T6">IARM_Bus_Init</span><span class="T7"> : </span></p><p><span class="T1">char *-(test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>4.IARMBUS_Agent deregister the event handler.</p><p>5.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for failure status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Unregister with out Register Event Handler test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro7"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_6</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Releasing acquired resource by a process.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char *, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t -  IR_event_callback</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> - None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> - None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregister the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Release Resource test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro8"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_7</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Requesting for a resource which is already allocated for another application.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon ( First application) .</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application).</p><p>4.Second application will request and acquire  “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>5.IARMBUS_Agent application will request for a resource which is currently acquired by second application.</p><p>6.Second application will release the resource and the resource will be utilized by IARMBUS_Agent application.</p><p>7.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>8.Both the applications  deregister from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Request same resource in different application test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_8</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Requesting a resource from the application for which, the same resource  is already allocated .</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> :</span><span class="T8"> </span><span class="T7">IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent request for a resource “IARM_BUS_RESOURCE_FOCUS”.</p><p>4.IARMBUS_Agent will again request for the same resource “IARM_BUS_RESOURCE_FOCUS” before releasing it.</p><p>5.IARMBUS_Agent will release the resource “IARM_BUS_RESOURCE_FOCUS”</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Request same resource from same application test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_9</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS -Request for Decoder-0 resource.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_0</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_0.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_0.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Request decoder-0 test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_10</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS -Request for Decoder-1 resource.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Request decoder-1 test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_11</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS -Request for Graphics plane-0 resource.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">Char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_0</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_PLANE_0.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_PLANE_0.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Request graphics plane-0 test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_12</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS -Request for Graphics plane-1 resource.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_1</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_1</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_PLANE_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_PLANE_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Request graphics plane-1 test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_13</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS - Request for display resolution change<span class="T1"> resource.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_RESOLUTION</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_RESOLUTION</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_RESOLUTION.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_RESOLUTION.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Request display_resolution_change  test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_14</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS - Request for power<span class="T1"> resource.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">Char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t -</span></p><p><span class="T1">IARM_BUS_RESOURCE_POWER</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_POWER</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_POWER.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_POWER.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Request power  test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro11"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_15</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Registering an RPC method that can be invoked by other applications.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall(const char *, IARM_BusCall_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterCall</span><span class="T7"> : </span></p><p><span class="T1">const char * -</span><span class="T8"> </span><span class="T9">IARM_BUS_COMMON_API_ReleaseOwnership</span></p><p><span class="T1">IARM_BusCall_t- releaseOwnershipHandler</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent registers a RPC methods for releasing the resource that can be invoked by other application.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS RegisterCall test</p></td><td style="text-align:left;width:96.69pt; " class="ce30"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro8"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_16</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Invoke RPC methods that is registered in another application.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall(const char *, IARM_BusCall_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterCall</span><span class="T7"> : </span></p><p><span class="T1">const char * -</span><span class="T8"> </span><span class="T7">IARM_BUS_PWRMGR_API_GetPowerState</span></p><p><span class="T1">IARM_BusCall_t - _GetPowerStatecallback</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> : </span></p><p><span class="T1">const char *- IARM_BUS_PWRMGR_NAME,     const char * - IARM_BUS_PWRMGR_API_GetPowerState  , void * -param, size_t - sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2.“pwrMgrMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.pwrMgrMain registers a RPC methods for setting the power state and this RPC can be invoked by IARMBUS_Agent application.</p><p>5.IARMBUS_Agent Invoke the RPC method of pwrMgrMain application to get the power state of STB. </p><p>6.IARMBUS_Agent deregister from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterCall</p><p>6.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro12"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_17</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting the event to application through IARMBus .</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce2"><p> </p><p><span class="T6">IARM_Bus_Init</span><span class="T7"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">ARM_Bus_RegisterEventHandler</span><span class="T7"> :</span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T6">IARM_Bus_BroadcastEvent</span><span class="T7"> :</span></p><p><span class="T1">const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t -  IARM_BUS_IRMGR_EVENT_IRKEY, </span></p><p><span class="T1">Void *- eventData, size_t- sizeof(eventData) </span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :</span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2.“pwrMgrMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (first application). </p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application).</p><p>4.Second application will publish “IARM_BUS_IRMGR_EVENT_IRKEY “ to the IARMBUS_Agent.</p><p>5.IARMBUS_Agent will register for IR key events.</p><p>6.The IARMBUS_Agent should receive the IR key notification. On notification, IARMBUS_Agent keeps value of last received key.</p><p>7.IARMBUS_Agent will deregisters the event handler.</p><p>8.TM makes RPC call for getting last received from first applications.</p><p>9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2</span><span class="T7">.Check for the correct key name for the key code received for both the test applications.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Broadcast IR event</p></td><td style="text-align:left;width:96.69pt; " class="ce30"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_18</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_DISKMGR_EVENT_HWDISK</span><span class="T2">” event.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_HWDISK, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent</span><span class="T7"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_HWDISK ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_HWDISK</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_HWDISK” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_DiskMgr_Event_HwDisk_18</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_19</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_DISKMGR_EVENT_EXTHDD” event.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_DiskMgr_Event_ExtHDD_19</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_20</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_DISKMGR_EVENT_EXTHDD” event with event type DISKMGR_EVENT_EXTHDD_PAIR.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_DiskMgr_Event_ExtHDD_Pair_20</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_21</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_DISKMGR_EVENT_EXTHDD” event with event type DISKMGR_EVENT_EXTHDD_ON.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_DiskMgr_Event_ExtHDD_On_21</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_22</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_DISKMGR_EVENT_EXTHDD” event with event type DISKMGR_EVENT_EXTHDD_OFF.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_DiskMgr_Event_ExtHDD_Off_22</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_23</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying Key Repeat Interval time for STB</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">Const char * - IARM_BUS_IRMGR_API_GetRepeatInterval</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.IARMBUS_Agent will invoke the RPC method for querying the key repeat interval time.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Query Key Repeat Interval test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro17"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_24</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Setting Key Repeat Interval time for STB .</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_API_GetRepeatInterval,</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> : </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_API_SetRepeatInterval</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent will invoke the RPC for getting the key repeat interval time.  </p><p>4.IARMBUS_Agent will return the Key Repeat Interval to the Test Agent.</p><p>5.IARMBUS_Agent will set key repeat time.</p><p><span class="T1">6.IARMBUS_Agent will invoke the RPC for getting the key repeat interval time.</span></p><p><span class="T1">7.IARMBUS_Agent will return the Key Repeat Interval to the Test Agent.  </span></p><p><span class="T1">8.Test Agent will compare the Key Repeat Interval time before and after setting it.</span></p><p><span class="T1">9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</span></p><p><span class="T1">10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2</span><span class="T7">.Check the Key Repeat  interval before and after setting the value.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Set Key Repeat Interval test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_25</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying the   Power state of STB from the process.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()  </span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> :</span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME,     const char* - </span></p><p><span class="T1">IARM_BUS_PWRMGR_API_GetPowerState,</span></p><p><span class="T1">void * -param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p><span class="T1">2.“pwrMgrMain” process should be running.</span></p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent Invoke the RPC call for getting the Power state of STB.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2</span><span class="T7">.Check the Power state before and after pressing the power key</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Query Power state</p></td><td style="text-align:left;width:96.69pt; " class="ce30"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_26</p></td><td style="text-align:left;width:140.34pt; " class="ce10"><p>IARMBUS- Setting the Power state of STB from the process.</p></td><td style="text-align:left;width:77.7pt; " class="ce10"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall<span class="T1">(const char *methodName, IARM_BusCall_t handler)</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</span></p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()  </span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> : </span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_PWRMGR_API_SetPowerState,</span></p><p><span class="T1">Void * - param,size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_PWRMGR_NAME , IARM_EventId_t - IARM_BUS_PWRMGR_EVENT_MODECHANGED ,</span></p><p><span class="T1">IARM_EventHandler_t - _handler_Powermodechanged </span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler </span><span class="T7">: </span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_PWRMGR_EVENT_MODECHANGED</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> : </span></p><p><span class="T1">const char* IARM_BUS_PWRMGR_NAME, const char* - </span></p><p><span class="T1">IARM_BUS_PWRMGR_API_GetPowerState,</span></p><p><span class="T1">void * -param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>IARMDaemonMain process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce10"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_PWRMGR_EVENT_MODECHANGED” event and waits on event.</p><p>4. TM makes RPC calls for getting the power state from IARMBUS_Agent</p><p>5.TM makes RPC calls for setting the new power state from IARMBUS_Agent</p><p>6.TM makes RPC calls for querying the latest power state from IARMBUS_Agent .</p><p>7.TM  compares the two power state for successful change in the power state</p><p>8.TM queries the last received event details to get the "IARM_BUS_PWRMGR_EVENT_MODECHANGED"event.</p><p>9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce22"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2</span><span class="T7">.Check the Power state before and after setting the power state using API.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint3:</span><span class="T7">Check whether the IARM_BUS_PWRMGR_EVENT_MODECHANGED event is received</span></p></td><td style="text-align:left;width:63.41pt; " class="ce10"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Set Power state</p></td><td style="text-align:left;width:96.69pt; " class="ce31"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro11"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_27</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Registering all the Events before publishing and receiving events.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEvent(int )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEvent</span><span class="T7"> :</span></p><p><span class="T1">Int - IARM_BUS_IRMGR_EVENT_MAX</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register all the events ie maximum number of events that any manager can have.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterEvent</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS RegisterEventMax</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro12"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_28</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Receiving “RESOURCE AVAILABLE” event.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> :</span><span class="T8"> </span><span class="T7">IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMON_NAME , IARM_EventId_t - IARM_BUS_EVENT_RESOURCEAVAILABLE, IARM_EventHandler_t - _handler_ResourceAvailable </span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* - IARM_BUS_DAEMON_NAME, IARM_EventId_t – IARM_BUS_EVENT_RESOURCEAVAILABLE</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOURCEAVAILABLE” event and waits on event.</p><p>5.Second application will release the resource.</p><p>6.IARMBUS_Agent should receive “RESOURCE AVAILABLE” event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Register for Resource Available event test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_29</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">RESOLUTIONCHANGE</span><span class="T2">” event.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMON_NAME , IARM_EventId_t - IARM_BUS_EVENT_RESOLUTIONCHANGE, IARM_EventHandler_t - _handler_ResolutionChange </span></p><p><span class="T6">IARM_Bus_BroadcastEvent</span><span class="T7"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DAEMON_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_EVENT_RESOLUTIONCHANGE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMON_NAME , IARM_EventId_t – IARM_BUS_EVENT_RESOLUTIONCHANGE</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS Broadcast ResolutionChange Event test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro19"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_30</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) manufacture name.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MANUFACTURER,</span></p><p><span class="T1">size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board manufacture name. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-STB Manufature Name test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro20"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_31</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) manufacture OUI(</p><p>Organizationally Unique Identifier).</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MANUFACTUREROUI ,</span></p><p><span class="T1">size_t - sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board manufacture OUI(Originally Unique Identifier). </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-OUI test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro21"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_32</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) model name.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MODELNAME,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board model name. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-Model Name test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro22"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_33</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) description.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_DESCRIPTION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board description. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-Board description test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro22"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_34</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) product class.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_PRODUCTCLASS,</span></p><p><span class="T1">size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board product class. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-Board Product Class test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro23"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_35</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) serial number .</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_SERIALNUMBER,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board serial number. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-SerialNumber test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro24"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_36</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) hardware version.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_HARDWAREVERSION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board hardware version. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-Hardware version test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro25"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_37</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) software version.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_SOFTWAREVERSION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board software version. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-Software version test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro26"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_38</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) provisioning code.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_PROVISIONINGCODE,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board provisioning code. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR- Provision Code test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_39</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) First Use Date.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_FIRSTUSEDATE,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board last use date. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS BusCall MFR-First Use Date test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Test will fail on boxes not running mfrMgrMain</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_40</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Creating and Calling Dummy RPC calls for 'x' times</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_RegisterCall(const char *methodName, IARM_BusCall_t handler)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DUMMYMGR_NAME,</span></p><p><span class="T1">Const char * - IARM_BUS_DUMMYMGR_API_DummyAPI0</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p> </p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon(First Application). </p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which Registers the Dummy RPC calls) .</p><p>4.IARMBUS_Agent will invoke the Dummy RPC method .</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6. Repeat steps 3-5 for 'x' times</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_DummyCall_Persistent_test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_41</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving of Dummy Event for 'x' times</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DUMMYMGR_NAME , IARM_EventId_t - IARM_BUS_DUMMYMGR_EVENT_DUMMYX, IARM_EventHandler_t - _handler_ResolutionChange </span></p><p><span class="T6">IARM_Bus_BroadcastEvent</span><span class="T7"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DUMMYMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DUMMYMGR_EVENT_DUMMYX ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DUMMYMGR_NAME , IARM_EventId_t – IARM_BUS_DUMMYMGR_EVENT_DUMMYX</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7. Repeat steps3 to 6 for 'x' times .</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_DummyEvt_Persistent_test</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_42</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Terminating an application with IARMBUS without Initializing</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce2"><p> </p><p> </p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p> </p><p>1.TestMgr_IARMBUS_Term</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_Term_Without_Init_42</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:114.15pt; " class="ce3"><p>CT_IARMBUS_43</p></td><td style="text-align:left;width:140.34pt; " class="ce3"><p>IARMBUS – Initializing IARMBUS with parameter as symbols</p></td><td style="text-align:left;width:77.7pt; " class="ce3"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce3"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce3"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce21"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce3"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:177.59pt; " class="ce21"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce3"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:256.9pt; " class="ce24"><p>IARMBUS_Init_with_Invalidparameter_test_43</p></td><td style="text-align:left;width:96.69pt; " class="ce32"><p>Removed in M29</p><p>Reason : As per DELIA-4986, This is not a valid test case.</p></td><td style="text-align:left;width:64.2pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:114.15pt; " class="ce3"><p>CT_IARMBUS_44</p></td><td style="text-align:left;width:140.34pt; " class="ce3"><p>IARMBUS – Initializing IARMBUS with invalid application as parameter</p></td><td style="text-align:left;width:77.7pt; " class="ce3"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce3"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce3"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce21"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce3"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:177.59pt; " class="ce21"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce3"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:256.9pt; " class="ce24"><p>IARMBUS_Init_with_Invalid_App_test_44</p></td><td style="text-align:left;width:96.69pt; " class="ce32"><p>Removed in M29</p><p>Reason : As per DELIA-4986, This is not a valid test case.</p></td><td style="text-align:left;width:64.2pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_45</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Unregister event handler for removing listener for a positive event ID.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> - None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> - None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce25"><p>IARMBUS_unregisterEvtHandler_With_PosId_45</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:114.15pt; " class="ce4"><p>CT_IARMBUS_46</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Unregister event handler for removing listener for a invalid event ID.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - 9</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> - None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> - None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent fails to deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_unregisterEvtHandler_With_NegId_46</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce2"><p>Script Not Available</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_47</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Register event handler and deregistering the same for positive event ID.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t -  1</span></p><p><span class="T1"> IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - 1 </span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> - None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> - None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for an event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_RegisterEvtHandler_With_PosId_47</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:114.15pt; " class="ce3"><p>CT_IARMBUS_48</p></td><td style="text-align:left;width:140.34pt; " class="ce3"><p>IARMBUS – Register event handler and deregistering for negative event ID </p></td><td style="text-align:left;width:77.7pt; " class="ce3"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce3"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce3"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce21"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - 9</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> - None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> - None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce3"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for negative invalid event and fails to register.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce21"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce3"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce24"><p>IARMBUS_RegisterEvtHandler_With_NegId_48</p></td><td style="text-align:left;width:96.69pt; " class="ce32"><p> it is not a valid scenario (XONE-14090)</p></td><td style="text-align:left;width:64.2pt; " class="ce3"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="ce37"> </td></tr><tr class="ro28"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_49</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS -Request for Invalid resource type</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_DECODER_10</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for an invalid resource. </p><p>4.IARMBUS_Agent will fails to release invalid resource </p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_Request_Invalid_Resource_49</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_50</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS -Request for FOCUS resource.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_MAX</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_Request_FOCUS_Resource_50</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_51</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Register and deregistering event handler for every 100 milli seconds for multiple times.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Stress</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t -  1</span></p><p><span class="T1"> IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - 1 </span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> - None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> - None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for an event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p>9.Above steps 3 to 7 will repeat for  “x” number of  times and sends the result to TM.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_RegUnReg_STRESS_51</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_52</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS -Release ownership with invalid resource.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_MAX</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_Release_Invalid_Resource_52</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_53</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Checking process registration status without registering it with IARMDaemon Manager</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_IsConnected(const char *, int *)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_IsConnected</span><span class="T7"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with UI Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_IsConnect_Without_Connect_53</p></td><td style="text-align:left;width:96.69pt; " class="ce30"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_54</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Checking process registration status with invalid member name, with IARMDaemon Manager</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_IsConnected(const char *, int *)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_IsConnected</span><span class="T7"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_IsConnected_Invalid_Membername_54</p></td><td style="text-align:left;width:96.69pt; " class="ce30"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_55</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Checking Iarmbus disconnect without connecting.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_Disconnect_without_connect_55</p></td><td style="text-align:left;width:96.69pt; " class="ce30"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro29"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_56</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS -Request multiple alternate resources for multiple times with every 100 mill seconds gap.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Stress</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_MAX</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p>7. Above 3 to 4 steps will be repeated for n number times and the result will be passed to TM</p></td><td style="text-align:left;width:177.59pt; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_Request_resource_STRESS_56</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p> </p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_57</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Connecting and Disconnect  IARMBUS for multiple times with gap of every 100 milli seconds</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Stress</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p><p><span class="T1">5.Above 3 and 4 steps will be repeated for n number times and the result will be passed to TM.</span></p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_IsConnect_STRESS_57</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_58</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) Device MAC</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_DEVICEMAC,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying Device Mac. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_BusCall_MFR-Device_MAC_58</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>This testcase is applicable on broadcom devices only</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_59</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) MOCA MAC</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MOCAMAC,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying Moca Mac data. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_BusCall_MFR-MOCA_MAC_59</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>This testcase is applicable on broadcom devices only</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_60</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Querying board (STB) HDMI HDCP</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_HDMIHDCP,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying HDMI HDCP data. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_BusCall_MFR-HDMIHDCP_60</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>This testcase is applicable on broadcom devices only</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_61</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Deleting PDRI image from box using IARM_BUS_MFRLIB_API_DeletePDRI RPC call</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_DeletePDRI,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for deleting PDRI image using IARM_BUS_MFRLIB_API_DeletePDRI.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_BusCall_MFR-DeletePDRI_image_61</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>This testcase is applicable on broadcom devices only</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_62</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Scrub all banks from box using IARM_BUS_MFRLIB_API_ScrubAllBanks RPC call</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_ScrubAllBanks,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for scrub all banks using IARM_BUS_MFRLIB_API_ScrubAllBanks.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_BusCall_MFR-Scruballbanks_62</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_63</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Validate and write image into the flash using IARM_BUS_MFRLIB_API_WriteImage RPC call</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_WriteImage,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect –</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term –</span><span class="T7"> None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for validate and write image into the flash using IARM_BUS_MFRLIB_API_WriteImage.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for failure status</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_BusCall_MFR-Validateandwriteimage_into_flash_63</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>This testcase is applicable on broadcom devices only</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M25</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_64</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Reset the box to warehouse state using IARM_BUS_PWRMGR_API_WareHouseReset RPC call</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()  </span></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Call</span><span class="T7"> :</span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME,     const char* - </span></p><p><span class="T1">IARM_BUS_PWRMGR_API_WareHouseReset,</span></p><p><span class="T1">void * -param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p><span class="T1">2.“pwrMgrMain” process should be running.</span></p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent Invoke the RPC call for reset the box to ware house state..</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1<span class="T1">.</span><span class="T2">Check the return value of API for success status.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_Reset_WareHouse_state_64</p></td><td style="text-align:left;width:96.69pt; " class="ce30"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro31"><td colspan="13" style="text-align:left;width:114.15pt; " class="ce5"><p>Sys Mgr</p></td><td style="text-align:left;width:64.2pt; " class="ce35"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_65</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_STB_SERIAL_NO and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_STB_SERIAL_NO), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_StbSerialNo_65</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_66</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_BOOTUP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_BOOTUP), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_BootUp_66</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_67</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS –Get and set HDCP profile using  IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call.</p><p>IARM_BUS_SYSMGR_API_SetHDCPProfile RPC call</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetHDCPProfile), to get the HDCP profile value.</p><p>4.Get the HDCP profile value and set it to the other HDCP profile value using IARM_BUS_SYSMGR_API_SetHDCPProfile.</p><p>5.Compare the set HDCP profile value by getting the value from  (IARM_BUS_SYSMGR_API_SetHDCPProfile)RPC call.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the HDCP profile set and get value using the RPC call</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_GetSetHDCPProfile_67</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_68</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS –Receiving event IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE upon changing the HDCP profile </p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandle</span><span class="T7">r : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3..IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE” event and waits on event.</p><p>4.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetHDCPProfile), to get the HDCP profile value.</p><p>5.Get the HDCP profile value and set it to the other HDCP profile value using IARM_BUS_SYSMGR_API_SetHDCPProfile.</p><p>6.IARMBUS_Agent should check the last received event for IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE.</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the last received event for HDCP profile update event.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_Bus Call</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_HDCPProfileEvent_68</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_70</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler :</span><span class="T7"> </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_70</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_71</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST” event.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_XUPNP_Data_Request_71</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_72</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE” event.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_XUPNP_Data_Update_72</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_73</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD” event.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_Card_FwDNLD_73</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_74</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE” event.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE, IARM_EventHandler_t - _evthandler </span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_Card_FwDNLD_73</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_75</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CHANNELMAP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CHANNELMAP), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_ChannelMap_75</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_76</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DISCONNECTMGR and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DISCONNECTMGR), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DisconnectMGR_76</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_77</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_TUNEREADY and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init :<span class="T1"> </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_TUNEREADY), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_TuneReady_77</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_78</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_EXIT_OK and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_EXIT_OK), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_ExitOk_78</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_79</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CMAC and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CMAC), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CMAC_79</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_80</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_MOTO_ENTITLEMENT and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_MOTO_ENTITLEMENT), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_MotoEntitlement_80</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_81</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_MOTO_HRV_RX and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_MOTO_HRV_RX), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_MotoHRVRX_81</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_82</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CARD_CISCO_STATUS and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CARD_CISCO_STATUS), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CardCisco_Status_82</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_83</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_VIDEO_PRESENTING and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_VIDEO_PRESENTING), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_VideoPresenting_83</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_84</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_HDMI_OUT and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_HDMI_OUT), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_HDMIOut_84</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_85</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_HDCP_ENABLED and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_HDCP_ENABLED), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_HDCPEnabled_85</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_86</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_HDMI_EDID_READ and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_HDMI_EDID_READ), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_HDMI_EDID_Ready_86</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_87</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_FIRMWARE_DWNLD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_FIRMWARE_DWNLD), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Term :</span><span class="T7"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_FirmwareDWLD_87</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_88</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_TIME_SOURCE and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_TIME_SOURCE), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_TimeSource_88</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_89</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_TIME_ZONE and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_TIME_ZONE), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_TimeZone_89</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_90</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CA_SYSTEM and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CA_SYSTEM), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CASystem_90</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_91</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_ESTB_IP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_ESTB_IP), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_EstbIP_91</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_92</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_ECM_IP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_ECM_IP), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_ECMIP_92</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_93</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_LAN_IP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_LAN_IP), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_LANIP_93</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_94</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_MOCA and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_MOCA), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_Moca_94</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_95</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DOCSIS and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DOCSIS), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_Docsis_95</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_96</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DSG_BROADCAST_CHANNEL and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DSG_BROADCAST_CHANNEL), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DsgBroadCastChannel_96</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_97</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DSG_CA_TUNNEL and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DSG_CA_TUNNEL), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DSG_CATunnel_97</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_98</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce26"><p>IARM_BUS_SysMgr_Event_SysState_CableCard_98</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_99</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD_DWNLD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD_DWNLD), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CableCardDWLD_99</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_100</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CVR_SUBSYSTEM and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CVR_SUBSYSTEM), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CVRSubsystem_100</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_101</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DOWNLOAD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DOWNLOAD), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_Download_101</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_102</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_VOD_AD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_VOD_AD), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_VOD_AD_102</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_103</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DAC_INIT_TIMESTAMP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DAC_INIT_TIMESTAMP), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DAC_InitTimeStamp_103</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_104</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD_SERIAL_NO and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD_SERIAL_NO), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CableCard_SerialNo_104</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_105</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_ECM_MAC and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_ECM_MAC), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_ECMMac_105</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_106</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DAC_ID and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DAC_ID), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DACId_106</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_107</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T2">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_PLANT_ID and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_PLANT_ID), size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_PlantId_107</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro31"><td colspan="13" style="text-align:left;width:114.15pt; " class="ce5"><p>JIRA Tickets Mapped</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro34"><td style="text-align:left;width:114.15pt; " class="ce6"><p>CT_IARMBUS_108</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>Check if sending multiple KEY_DOWN and KEY_UP events in a row and check if the events are handled successfully</p></td><td style="text-align:left;width:77.7pt; " class="ce15"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce16"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce12"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:127.64pt; " class="ce12"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:268.75pt; " class="ce12"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast digit3 key press and key release event 50 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce12"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:63.41pt; " class="ce12"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce12"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:256.9pt; " class="ce12"><p>IARM_BUS_IRMgr_IRKey_Toggle</p></td><td style="text-align:left;width:96.69pt; " class="ce12"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="ce12"><p>BPV-8212 </p></td></tr><tr class="ro34"><td style="text-align:left;width:114.15pt; " class="ce6"><p>CT_IARMBUS_109</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>Check if multiple IR event notification is received for repeated key press/release for keys: channel up, channel down, Volume Up, Volume Down</p></td><td style="text-align:left;width:77.7pt; " class="ce15"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce16"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce12"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:127.64pt; " class="ce12"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:268.75pt; " class="ce12"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast CHANNELUP/CHANNELDOWN/VOLUMEUP/VOLUMEDOWN key press and key release event 5 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce12"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:63.41pt; " class="ce12"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce12"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:256.9pt; " class="ce12"><p>IARM_BUS_IRMgr_IRKey_ChangeChannelVol</p></td><td style="text-align:left;width:96.69pt; " class="ce12"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="ce12"><p>DELIA-496</p></td></tr><tr class="ro34"><td style="text-align:left;width:114.15pt; " class="ce6"><p>CT_IARMBUS_110</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>Check if multiple IR event notification is received for repeated key press/release for trickplay keys (REW/FF/PLAY/STOP/PAUSE)</p></td><td style="text-align:left;width:77.7pt; " class="ce15"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce16"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce12"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:127.64pt; " class="ce12"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:268.75pt; " class="ce12"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast (REW/FF/PLAY/STOP/PAUSE) key press and key release event 5 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce12"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:63.41pt; " class="ce12"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce12"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:256.9pt; " class="ce12"><p>IARM_BUS_IRMgr_IRKey_CheckTrickplay</p></td><td style="text-align:left;width:96.69pt; " class="ce12"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="ce12"><p>DELIA-496</p></td></tr><tr class="ro34"><td style="text-align:left;width:114.15pt; " class="ce6"><p>CT_IARMBUS_111</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>Check if multiple IR event notification is received for repeated key press/release for Search key</p></td><td style="text-align:left;width:77.7pt; " class="ce15"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce16"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce12"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:127.64pt; " class="ce12"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:268.75pt; " class="ce12"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast SEARCH key press and key release event 50 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce12"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:63.41pt; " class="ce12"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce12"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:256.9pt; " class="ce12"><p>IARM_BUS_IRMgr_IRKey_CheckSearch</p></td><td style="text-align:left;width:96.69pt; " class="ce12"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M21</p></td><td style="text-align:left;width:64.2pt; " class="ce12"><p>DELIA-496</p></td></tr><tr class="ro34"><td style="text-align:left;width:114.15pt; " class="ce6"><p>CT_IARMBUS_112</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>Check if multiple IR event notification is received for repeated key press/release for Setup key</p></td><td style="text-align:left;width:77.7pt; " class="ce15"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce16"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:140.34pt; " class="ce12"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce12"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:127.64pt; " class="ce12"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:268.75pt; " class="ce12"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast SETUP key press and key release event 50 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce12"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:63.41pt; " class="ce12"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce12"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:256.9pt; " class="ce12"><p>IARM_BUS_IRMgr_IRKey_CheckSetup</p></td><td style="text-align:left;width:96.69pt; " class="ce12"> </td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce12"><p>DELIA-496</p></td></tr><tr class="ro35"><td style="text-align:left;width:114.15pt; " class="ce7"><p>CT_IARMBUS_113</p></td><td style="text-align:left;width:140.34pt; " class="ce13"><p>Check multiple (50 times) toggles between STB Standby and Power-on</p></td><td style="text-align:left;width:77.7pt; " class="ce13"><p>Positive(Stress)</p></td><td style="text-align:left;width:108.6pt; " class="ce17"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:140.34pt; " class="ce13"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce2"><p>IARM_Bus_Init : </p><p>char *  - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>IARM_Bus_RegisterCall : </p><p>const char * - IARM_BUS_PWRMGR_API_GetPowerState</p><p>IARM_BusCall_t - _GetPowerStatecallback</p><p>IARM_Bus_Call : </p><p>const char *- IARM_BUS_PWRMGR_NAME,     const char * - IARM_BUS_PWRMGR_API_GetPowerState  , void * -param, size_t - sizeof(param)</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2.“pwrMgrMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce13"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.pwrMgrMain registers a RPC methods for setting the power state and this RPC can be invoked by IARMBUS_Agent application.</p><p>4.IARMBUS_Agent Invoke the RPC method of pwrMgrMain application to set the power state of STB.</p><p>5.IARMBUS_Agent Invoke the RPC method of pwrMgrMain application to get the power state of STB. </p><p>6.Repeat steps 2 to 5 for power state values STANDBY (1) and ON (2) for 50 times.</p><p>7.IARMBUS_Agent deregister from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce13"><p>Checkpoint 1.Check the return value of API for success status.</p></td><td style="text-align:left;width:63.41pt; " class="ce13"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce13"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:256.9pt; " class="ce13"><p>IARMBUS_PowerModeToggle_Stress</p></td><td style="text-align:left;width:96.69pt; " class="ce33"><p>This is skipped till RDKTT-152 is fixed.</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce38"> </td></tr><tr class="ro7"><td style="text-align:left;width:114.15pt; " class="ce8"><p>CT_IARMBUS_114</p></td><td style="text-align:left;width:140.34pt; " class="ce14"><p>Check if STB is able to tune to linear channel when going from StandBy to On state.</p></td><td style="text-align:left;width:77.7pt; " class="ce14"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce18"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:140.34pt; " class="ce14"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce14"><p>IARM_Bus_Init : </p><p>char *  - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>IARM_Bus_RegisterCall : </p><p>const char * - IARM_BUS_PWRMGR_API_GetPowerState</p><p>IARM_BusCall_t - _GetPowerStatecallback</p><p>IARM_Bus_Call : </p><p>const char *- IARM_BUS_PWRMGR_NAME,     const char * - IARM_BUS_PWRMGR_API_GetPowerState  , void * -param, size_t - sizeof(param)</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:127.64pt; " class="ce14"><p>1. “IARMDaemonMain” Process should be running.</p><p>2. “pwrMgrMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce14"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.pwrMgrMain registers a RPC methods for setting the power state and this RPC can be invoked by IARMBUS_Agent application.</p><p>4.IARMBUS_Agent Invoke the RPC method of pwrMgrMain application to set the power state of STB to STANDBY (1).</p><p>5.TDKIntegrationStub Agent will play the live Url after changing the power mode and return SUCCESS or FAILURE based on the result.</p><p>6.IARMBUS_Agent Invoke the RPC method of pwrMgrMain application to set the power state of STB to ON (2).</p><p>7.TDKIntegrationStub Agent will play the live Url after changing the power mode and return SUCCESS or FAILURE based on the result.</p><p>8.IARMBUS_Agent deregister from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce14"><p>Checkpoint 1.Check the return value of API for success status.</p></td><td style="text-align:left;width:63.41pt; " class="ce14"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce14"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p> </p><p>tdkintegration.so</p><p>1.TestMgr_LinearTv_Dvr_Play</p></td><td style="text-align:left;width:256.9pt; " class="ce14"><p>IARMBUS_PowerModeToggle_Trickplay</p></td><td style="text-align:left;width:96.69pt; " class="ce34"><p>XONE-9619 </p></td><td style="text-align:left;width:64.2pt; " class="ce14"><p>This testcase is moved to tdk_integration as "E2E_RMF_PowerModeToggle_Trickplay.py"</p></td><td style="text-align:left;width:64.2pt; " class="ce38"> </td></tr><tr class="ro33"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_115</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Set HDCP profile0 using IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call and verify using IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetHDCPProfile), to get the HDCP profile value.</p><p>4.Get the HDCP profile value and set it to the other HDCP profile value using IARM_BUS_SYSMGR_API_SetHDCPProfile.</p><p>5.Compare the set HDCP profile value by getting the value from  (IARM_BUS_SYSMGR_API_SetHDCPProfile)RPC call.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the HDCP profile set and get value using the RPC call</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_SetHDCPProfileTo0_115</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:64.2pt; " class="ce38"> </td></tr><tr class="ro33"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_116</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Set HDCP profile1 using IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call and verify using IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetHDCPProfile), to get the HDCP profile value.</p><p>4.Get the HDCP profile value and set it to the other HDCP profile value using IARM_BUS_SYSMGR_API_SetHDCPProfile.</p><p>5.Compare the set HDCP profile value by getting the value from  (IARM_BUS_SYSMGR_API_SetHDCPProfile)RPC call.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the HDCP profile set and get value using the RPC call</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_SetHDCPProfileTo1_116</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:64.2pt; " class="ce38"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_117</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Get the HDCP profile using  IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetHDCPProfile), to get the HDCP profile value.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the HDCP profile get value using the RPC call</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_GetHDCPProfile_117</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro36"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_118</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Set HDCP profile0 using IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call and verify if the value is persisted after reboot using IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.Set HDCP profile value to 0 using IARM_BUS_SYSMGR_API_SetHDCPProfile.</p><p>4. Reboot the device.</p><p>5.Compare the set HDCP profile value by getting the value from (IARM_BUS_SYSMGR_API_GetHDCPProfile) RPC call.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return value of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the HDCP profile set and get value using the RPC call</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_SetHDCPProfileTo0_Reboot_118</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro37"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_119</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Set HDCP profile1 using IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call and verify if the value is persisted after reboot using IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect :</span><span class="T7"> None</span></p><p><span class="T6">IARM_Bus_Call :</span><span class="T7"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T6">IARM_Bus_Disconnect : </span><span class="T7">None</span></p><p><span class="T6">IARM_Bus_Term : </span><span class="T7">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.Set HDCP profile value to 1 using IARM_BUS_SYSMGR_API_SetHDCPProfile.</p><p>4. Reboot the device.</p><p>5.Compare the set HDCP profile value by getting the value from (IARM_BUS_SYSMGR_API_GetHDCPProfile) RPC call.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return value of APIs.</p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the HDCP profile set and get value using the RPC call</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_SetHDCPProfileTo1_Reboot_119</p></td><td style="text-align:left;width:96.69pt; " class="ce29"> </td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_120</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Releasing acquired resource by a process after unregistering from iarmbus.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_BusDaemon_RequestOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T1">IARM_Bus_Disconnect - None</span></p><p><span class="T1">IARM_Bus_Term - None</span></p><p><span class="T6">IARM_BusDaemon_ReleaseOwnership</span><span class="T7"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:256.9pt; " class="ce25"><p>IARMBUSReleaseResourceNegativeTest</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Developed on request through RDKTT-559</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>M28</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro38"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_121</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Broadcasting and Receiving of Dummy Event for 'x' times</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DUMMYMGR_NAME , IARM_EventId_t - IARM_BUS_DUMMYMGR_EVENT_DUMMYX, IARM_EventHandler_t - _handler_ResolutionChange </span></p><p><span class="T6">IARM_Bus_BroadcastEvent</span><span class="T7"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DUMMYMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DUMMYMGR_EVENT_DUMMYX ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DUMMYMGR_NAME , IARM_EventId_t – IARM_BUS_DUMMYMGR_EVENT_DUMMYX</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7. Repeat steps3 to 6 for 'x' times .</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:256.9pt; " class="ce19"><p>IARMBUS_DummyEvt_Persistent_test_LD</p></td><td style="text-align:left;width:96.69pt; " class="ce29"><p>Developed on request through RDKTT-620</p></td><td style="text-align:left;width:64.2pt; " class="ce36"><p>M33</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_122</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Registering a NULL event handler shall fail</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - NULL</span></p><p><span class="T1"/></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMONMGR , IARM_EventId_t – 0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event using a NULL event handler.(should fail)</p><p>5.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>IARMBus_Register_NULL_EventHandler_122.py</p></td><td style="text-align:left;width:256.9pt; " class="ce2"><p>Developed on request through RDK-14067</p></td><td style="text-align:left;width:96.69pt; " class="ce35"><p>M35</p></td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_123</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – Registering the same event handler twice shall fail</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - NULL</span></p><p><span class="T1"/></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMONMGR , IARM_EventId_t – 0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event using a  event handler.(should pass)</p><p>5.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event using a  event handler.(should fail)</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>IARMBus_Register_same_EventHandler_Twice_123.py</p></td><td style="text-align:left;width:256.9pt; " class="ce2"><p>Developed on request through RDK-14067</p></td><td style="text-align:left;width:96.69pt; " class="ce35"><p>M35</p></td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_124</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS-After IARM_Bus_UnRegisterEventHandler() all registered event handlers for the given event are removed, and the handlers are not invoked.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>All</p></td><td style="text-align:left;width:140.34pt; " class="ce19"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_IsConnected</span><span class="T7"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T6">IARMBUS_GetLastReceivedEventPerformanceDetails</span><span class="T9">: Average of response time.</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:127.64pt; " class="ce19"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent will register for “IARM_BUS_IREVENT” event and waits on event using a  event handler</p><p>5.IARMBUS_Agent will register for “IARM_BUS_IREVENT” event and waits on event using another event handler</p><p>6.IARMBUS_Agent will register for “IARM_BUS_IREVENT” event and waits on event using another event handler</p><p>7. Broadcast the event from another application and check whether all the event handlers are called</p><p>8. IARMBUS_Agent unregisters all event handler</p><p>9.Broadcast the event from another application and check whether all the event handlers are not called</p><p>10.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p> </p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce19"><p>Checkpoint 1.Check the return value of API.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:63.41pt; " class="ce19"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventPerformanceDetails</p><p>9.TestMgr_IARMBUS_RegisterMultipleEventHandler</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>IARMBus_Verify_after_UnRegister_Multiple_EventHandler_124.py</p></td><td style="text-align:left;width:256.9pt; " class="ce27"> </td><td style="text-align:left;width:96.69pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_125</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – IARM_Bus_RemoveEventHandler() remove a specifc handler and the handler is no longer invoked.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_RemoveEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - eventhandler</span></p><p><span class="T6">IARM_Bus_RemoveEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - eventhandler</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMONMGR , IARM_EventId_t – 0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event using a  event handler.(should pass)</p><p>5.IARMBUS_Agent will remove the event handler for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event .</p><p>6.IARMBUS_Agent should not receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p><p>9.TestMgr_IARMBUS_RemoveEventHandler</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>IARMBus_Remove_EventHandler_Verify_125.py</p></td><td style="text-align:left;width:256.9pt; " class="ce2"><p>Developed on request through RDK-14067</p></td><td style="text-align:left;width:96.69pt; " class="ce35"><p>M35</p></td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_126</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – IARM_Bus_RemoveEventHandler() remove a unreigstered handler shoud return INVALID_PARAM.</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_RemoveEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - eventhandler</span></p><p><span class="T6">IARM_Bus_RemoveEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - eventhandler</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMONMGR , IARM_EventId_t – 0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event using a  event handler.(should pass)</p><p>5.IARMBUS_Agent will unregister the event handler for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event .</p><p>6.IARMBUS_Agent should not be able to remove the event handler after unresiter</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p><p>9.TestMgr_IARMBUS_RemoveEventHandler</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>IARMBus_Remove_After_UnRegister_EventHandler_126.py</p></td><td style="text-align:left;width:256.9pt; " class="ce2"><p>Developed on request through RDK-14067</p></td><td style="text-align:left;width:96.69pt; " class="ce35"><p>M35</p></td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_127</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – IARM_Bus_RemoveEventHandler() remove a NULL event handler should fail</p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_RemoveEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - eventhandler</span></p><p><span class="T6">IARM_Bus_RemoveEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - eventhandler</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMONMGR , IARM_EventId_t – 0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event using a  event handler.(should pass)</p><p>5.IARMBUS_Agent will unregister the event handler for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event .</p><p>6.IARMBUS_Agent should not be able to remove a NULL event handler </p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p><p>9.TestMgr_IARMBUS_RemoveEventHandler</p></td><td style="text-align:left;width:193.44pt; " class="ce2"><p>IARMBus_Remove_NULL_EventHandler_127.py</p></td><td style="text-align:left;width:256.9pt; " class="ce2"><p>Developed on request through RDK-14067</p></td><td style="text-align:left;width:96.69pt; " class="ce35"><p>M35</p></td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:114.15pt; " class="ce2"><p>CT_IARMBUS_128</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARMBUS – IARM_Bus_UnRegisterEventHanlder() should fail after removing the event handler using IARM_Bus_RemoveEventHandler() </p></td><td style="text-align:left;width:77.7pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:108.6pt; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:140.34pt; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_RemoveEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:185.5pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_RegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - eventhandler</span></p><p><span class="T6">IARM_Bus_RemoveEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMONMGR , IARM_EventId_t - 0, IARM_EventHandler_t - eventhandler</span></p><p><span class="T6">IARM_Bus_UnRegisterEventHandler</span><span class="T7"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMONMGR , IARM_EventId_t – 0</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:268.75pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event using a  event handler.(should pass)</p><p>5.IARMBUS_Agent will unregister the event handler for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event .</p><p>6.IARMBUS_Agent should not be able to remove a NULL event handler </p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:177.59pt; " class="ce20"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for  the print  message.</span></p></td><td style="text-align:left;width:63.41pt; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p><p>9.TestMgr_IARMBUS_RemoveEventHandler</p></td><td style="text-align:left;width:193.44pt; " class="ce23"><p>IARMBus_UnRegister_After_Remove_EventHandler_128.py</p></td><td style="text-align:left;width:256.9pt; " class="ce2"><p>Developed on request through RDK-14067</p></td><td style="text-align:left;width:96.69pt; " class="ce35"><p>M35</p></td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro40"><td style="text-align:left;width:114.15pt; " class="ce9"> </td><td style="text-align:left;width:140.34pt; " class="ce9"> </td><td style="text-align:left;width:77.7pt; " class="ce9"> </td><td style="text-align:left;width:108.6pt; " class="ce9"> </td><td style="text-align:left;width:140.34pt; " class="ce9"> </td><td style="text-align:left;width:185.5pt; " class="ce9"> </td><td style="text-align:left;width:127.64pt; " class="ce9"> </td><td style="text-align:left;width:268.75pt; " class="ce9"> </td><td style="text-align:left;width:177.59pt; " class="ce9"> </td><td style="text-align:left;width:63.41pt; " class="ce9"> </td><td style="text-align:left;width:193.44pt; " class="ce9"> </td><td style="text-align:left;width:256.9pt; " class="ce9"> </td><td style="text-align:left;width:96.69pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro40"><td style="text-align:left;width:114.15pt; " class="ce9"> </td><td style="text-align:left;width:140.34pt; " class="ce9"> </td><td style="text-align:left;width:77.7pt; " class="ce9"> </td><td style="text-align:left;width:108.6pt; " class="ce9"> </td><td style="text-align:left;width:140.34pt; " class="ce9"> </td><td style="text-align:left;width:185.5pt; " class="ce9"> </td><td style="text-align:left;width:127.64pt; " class="ce9"> </td><td style="text-align:left;width:268.75pt; " class="ce9"> </td><td style="text-align:left;width:177.59pt; " class="ce9"> </td><td style="text-align:left;width:63.41pt; " class="ce9"> </td><td style="text-align:left;width:193.44pt; " class="ce9"> </td><td style="text-align:left;width:256.9pt; " class="ce9"> </td><td style="text-align:left;width:96.69pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta2"><colgroup><col width="78"/><col width="220"/><col width="220"/><col width="230"/><col width="181"/><col width="78"/><col width="78"/><col width="139"/><col width="332"/><col width="144"/><col width="270"/><col width="78"/><col width="130"/><col width="122"/><col width="142"/><col width="78"/></colgroup><tr class="ro41"><td style="text-align:left;width:50.29pt; " class="ce39"><p>Feature Name</p></td><td style="text-align:left;width:142.7pt; " class="ce39"><p>Test Case ID</p></td><td style="text-align:left;width:142.7pt; " class="ce39"><p>Test Suite</p></td><td style="text-align:left;width:149.05pt; " class="ce39"><p>Test Case  Name</p></td><td style="text-align:left;width:117.35pt; " class="ce39"><p>Test Objective</p></td><td style="text-align:left;width:50.29pt; " class="ce39"><p>Test Type</p></td><td style="text-align:left;width:50.29pt; " class="ce39"><p>Test Setup</p></td><td style="text-align:left;width:90.4pt; " class="ce39"><p>Pre-requisite</p></td><td style="text-align:left;width:215.66pt; " class="ce39"><p>Automation Approach</p></td><td style="text-align:left;width:93.54pt; " class="ce39"><p>Exp Output</p></td><td style="text-align:left;width:175.21pt; " class="ce39"><p>Test script</p></td><td style="text-align:left;width:50.29pt; " class="ce39"><p>Jira Number</p></td><td style="text-align:left;width:84.05pt; " class="ce39"><p>Project/File Name</p></td><td style="text-align:left;width:79.31pt; " class="ce39"><p>Relevance</p></td><td style="text-align:left;width:91.96pt; " class="ce39"><p>Remarks</p></td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>Get the response time for the key KD_KEYA keytype: 32768 keycode: 290</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:290 and key type:32768 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>Get the response time for the key KD_KEYB keytype: 32768keycode: 291</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:291 and key type:32768 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KD_KEYC keytype: 32768 keycode: 292</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:292 and key type:32768 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for key: KD_KEYD keytype: 32768 keycode: 293</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:293 and key type:32768 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_KEYA keytype: 33024 keycode: 290</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:290 and key type:33024 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_KEYB keytype: 33024 keycode: 291</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:291 and key type:33024 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_07</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_07</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_KEYC keytype: 33024 keycode: 292</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:292 and key type:33024 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_08</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_08</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_KEYD keytype: 33024keycode: 293</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:293 and key type:33024 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_09</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_09</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key  RPT_KEYA keytype: 33280 keycode: 290</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:290 and key type:33280 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_10</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_10</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key RPT_KEYB keytype: 33280 keycode: 291</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:291 and key type:33280 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_11</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_11</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key RPT_KEYC keytype: 33280 keycode: 292</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:292 and key type:33280 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_ALPHA_ITER_TC_12</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p> TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p> twc_IRKEY_ALPHA_ITER_12</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key RPT_KEYD keytype: 33280 keycode: 293</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:293 and key type:33280 combination are stored in IRkey_Alpha_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p> twc_TWC_IRKEY_ALPHA_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for key: KD_PAGUP keytype: 32768 keycode: 266</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:266 and key type:32768 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KD_PAGDN keytype: 32768 keycode: 267</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:267 and key type:32768 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key  KD_CHANUP keytype: 32768 keycode: 268</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:268 and key type:32768 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key  KD_CHANDN keytype: 32768 keycode: 269</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:269 and key type:32768 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for key: KU_PAGUP keytype: 33024 keycode: 266</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:266 and key type:33024 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_PAGDN keytype: 33024 keycode: 267</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:267 and key type:33024 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_07</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_07</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key:  KU_CHANUP keytype: 33024 keycode: 268</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:268 and key type:33024 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_08</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_08</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key  KU_CHANDN keytype: 33024 keycode: 269</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:269 and key type:33024 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_09</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_09</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key RPT_PAGUP keytype: 33280 keycode: 266</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:266 and key type:33280 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_10</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_10</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key RPT_PAGDN keytype: 33280 keycode: 267</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:267 and key type:33280 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_11</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_11</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key  RPT_CHANUP keytype: 33280 keycode: 268</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:268 and key type:33280 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_TC_12</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER_12</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key  RPT_CHANDN keytype: 33280 keycode: 269</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:269 and key type:33280 combination are stored in IRkey_Channel-Page_Navigation_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_CHANNEL-PAGE_NAVIGATION_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key  KD_BACK keytype: 32768 keycode: 300</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:300 and key type:32768 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KD_ENTER keytype: 32768 keycode: 279</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:279 and key type:32768 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key:KD_EXIT keytype: 32768 keycode: 289</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:289 and key type:32768 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KD_INFO keytype: 32768 keycode: 262</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:262 and key type:32768 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KD_LAST keytype: 32768 keycode: 287</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:287 and key type:32768 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KD_LIVE keytype: 32768 keycode: 264</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:264 and key type:32768 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_07</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_07</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KD_MENU keytype: 32768 keycode: 261</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:261 and key type:32768 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_08</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_08</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KD_MUTE keytype: 32768 keycode: 274</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:274 and key type:32768 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_09</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_09</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_BACK keytype: 33024 keycode: 300</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:300 and key type:33024 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_10</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_10</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_ENTER keytype: 33024 keycode: 279</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:279 and key type:33024 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_11</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_11</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_EXIT keytype: 33024 keycode: 289</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:289 and key type:33024 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_12</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_12</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_INFO keytype: 33024 keycode: 262</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:262 and key type:33024 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_13</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_13</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_LAST keytype: 33024 keycode: 287</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:287 and key type:33024 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_14</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_14</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_LIVE keytype: 33024 keycode: 264</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:264 and key type:33024 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_15</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_15</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_MENU keytype: 33024 keycode: 261</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:261 and key type:33024 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_16</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_16</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key KU_MUTE keytype: 33024 keycode: 274</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:274 and key type:33024 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_17</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_17</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key RPT_BACK keytype: 33280 keycode: 300</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:300 and key type:33280 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_18</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_18</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key RPT_ENTER keytype: 33280 keycode: 279</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:279 and key type:33280 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_19</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_19</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-RPT_EXIT keytype: 33280 keycode: 289</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:289 and key type:33280 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_20</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_20</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-RPT_INFO keytype: 33280 keycode: 262</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:262 and key type:33280 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_21</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_21</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_LAST keytype: 33280 keycode: 287</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:287 and key type:33280 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_22</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_22</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_LIVE keytype: 33280 keycode: 264</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:264 and key type:33280 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_23</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_23</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_MENU keytype: 33280 keycode: 261</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:261 and key type:33280 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP1_ITER_TC_24</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP1_ITER_24</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_MUTE keytype: 33280 keycode: 274</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:274 and key type:33280 combination are stored in IRkey_keygroup1_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP1_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DVR keytype: 32768 keycode: 288</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:288 and key type:32768 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_GUIDE keytype: 32768 keycode: 260</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:266 and key type:32768 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_LIST keytype: 32768 keycode: 288</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:288 and key type:32768 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_ONDEM keytype: 32768 keycode: 294</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:294 and key type:32768 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_SEARCH keytype: 32768 keycode: 299</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:299 and key type:32768 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DVR keytype: 33024 keycode: 288</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:288 and key type:33024 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_07</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_07</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_GUIDE keytype: 33024 keycode: 260</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:266 and key type:33024 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_08</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_08</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_LIST keytype: 33024 keycode: 288</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:288 and key type:33024 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_09</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_09</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_ONDEM keytype: 33024 keycode: 294</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:294 and key type:33024 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_10</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_10</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key: KU_SEARCH keytype: 33024 keycode: 299</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:299 and key type:33024 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_11</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_11</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DVR keytype: 33280 keycode: 288</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:288 and key type:33280 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_12</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_12</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  RPT_GUIDE keytype: 33280 keycode: 260</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:266 and key type:33280 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_13</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_13</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_LIST keytype: 33280 keycode: 288</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:288 and key type:33280 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_14</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_14</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_ONDEM keytype: 33280 keycode: 294</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:294 and key type:33280 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP2_ITER_TC_15</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP2_ITER_15</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_SEARCH keytype: 33280 keycode: 299</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:299 and key type:33280 combination are stored in IRkey_keygroup2_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP2_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_BROWSE keytype: 32768 keycode: 294</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:294 and key type:32768 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_FAV keytype: 32768 keycode: 265</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:265 and key type:32768 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_NUMPOUND keytype: 32768 keycode: 295</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:295 and key type:32768 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key:KD_NUMSTAR keytype: 32768 keycode: 296</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:296 and key type:32768 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_SELECT keytype: 32768 keycode: 279</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:279 and key type:32768 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_BROWSE keytype: 33024 keycode: 294</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:294 and key type:33024 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_07</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_07</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_FAV keytype: 33024 keycode: 265</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:265 and key type:33024 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_08</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_08</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key:KU_NUMPOUND keytype: 33024 keycode: 295</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:295 and key type:33024 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_09</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_09</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_NUMSTAR keytype: 33024 keycode: 296</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:296 and key type:33024 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_10</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_10</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_SELECT keytype: 33024 keycode: 279</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:279 and key type:33024 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_11</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_11</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_BROWSE keytype: 33280 keycode: 294</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:294 and key type:33280 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_12</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_12</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  RPT_FAV keytype: 33280 keycode: 265</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:265 and key type:33280 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_13</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_13</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_NUMPOUND keytype: 33280 keycode: 295</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:295 and key type:33280 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_14</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_14</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_NUMSTAR keytype: 33280 keycode: 296</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:296 and key type:33280 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_KEYGROUP3_ITER_TC_15</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_KEYGROUP3_ITER_15</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_SELECT keytype: 33280 keycode: 279</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:279 and key type:33280 combination are stored in IRkey_keygroup3_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_KEYGROUP3_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_ARROWDOWN keytype: 32768 keycode: 276</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:276 and key type:32768 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_ARROWLEFT keytype: 32768 keycode: 277</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:277 and key type:32768 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_ARROWRIGHT keytype: 32768 keycode: 278</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:278 and key type:32768 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_ARROWUP keytype: 32768 keycode: 275</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:275 and key type:32768 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_ARROWDOWN keytype: 33024 keycode: 276</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:276 and key type:33024 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_ARROWLEFT keytype: 33024 keycode: 277</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:277 and key type:33024 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_07</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_07</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_ARROWRIGHT keytype: 33024 keycode: 278</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:278 and key type:33024 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_08</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_08</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_ARROWUP keytype: 33024 keycode: 275</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:275 and key type:33024 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_09</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_09</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key:  RPT_ARROWDOWN keytype: 33280 keycode: 276</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:276 and key type:33280 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_10</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_10</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_ARROWLEFT keytype: 33280 keycode: 277</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:277 and key type:33280 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_11</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_11</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_ARROWRIGHT keytype: 33280 keycode: 278</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:278 and key type:33280 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NAVIGATIONKEYS_ITER_TC_12</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NAVIGATIONKEYS_ITER_12</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  RPT_ARROWUP keytype: 33280 keycode: 275</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:275 and key type:33280 combination are stored in IRkey_Navigationkeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NAVIGATIONKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT0 keytype: 32764 keycode: 250</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:250 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT1 keytype: 32768 keycode: 251</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:251 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT2 keytype: 32768 keycode: 252</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:252 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT3 keytype: 32768 keycode: 253</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:253 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT4 keytype: 32768 keycode: 254</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:254 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT5 keytype: 32768 keycode: 255</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:255 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_07</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_07</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT6 keytype: 32768 keycode: 256</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:256 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_08</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_08</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT7 keytype: 32768 keycode: 257</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:257 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_09</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_09</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT8 keytype: 32768 keycode: 258</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:258 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_10</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_10</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_DIGIT9 keytype: 32768 keycode: 259</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:259 and key type:32768 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_11</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_11</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT0 keytype: 33024 keycode: 250</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:250 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_12</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_12</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT1 keytype: 33024 keycode: 251</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:251 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_13</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_13</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT2 keytype: 33024 keycode: 252</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:252 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_14</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_14</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT3 keytype: 33024 keycode: 253</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:253 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_15</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_15</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT4 keytype: 33024 keycode: 254</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:254 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_16</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_16</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT5 keytype: 33024 keycode: 255</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:255 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_17</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_17</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT6 keytype: 33024 keycode: 256</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:256 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_18</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_18</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT7 keytype: 33024 keycode: 257</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:257 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_19</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_19</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT8 keytype: 33024 keycode: 258</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:258 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_20</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_20</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_DIGIT9 keytype: 33024 keycode: 259</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:259 and key type:33024 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_21</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_21</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT0 keytype: 33280 keycode: 250</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:250 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_22</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_22</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT1 keytype: 33280 keycode: 251</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:251 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_23</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_23</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT2 keytype: 33280 keycode: 252</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:252 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_24</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_24</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT3 keytype: 33280 keycode: 253</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:253 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_25</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_25</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT4 keytype: 33280 keycode: 254</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:254 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_26</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_26</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT5 keytype: 33280 keycode: 255</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:255 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_27</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_27</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT6 keytype: 33280 keycode: 256</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:256 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_28</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_28</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT7 keytype: 33280 keycode: 257</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:257 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_29</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_29</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT8 keytype: 33280 keycode: 258</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:258 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_NUMERICKEYS_ITER_TC_30</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_NUMERICKEYS_ITER_30</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_DIGIT9 keytype: 33280 keycode: 259</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:259 and key type:33280 combination are stored in IRkey_Numerickeys_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_NUMERICKEYS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_PLAY keytype: 32768 keycode: 280</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:280 and key type:32768 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_STOP keytype: 32768 keycode: 281</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:281 and key type:32768 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_PAUSE keytype: 32768 keycode: 282</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:282 and key type:32768 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_FASTFORWARD keytype: 32768 keycode: 283</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:283 and key type:32768 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_REWIND keytype: 32768 keycode: 284</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:284 and key type:32768 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_RECORD keytype: 32768 keycode: 285</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:285 and key type:32768 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_07</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_07</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_REPLAY keytype: 32768 keycode: 286</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:286 and key type:32768 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_08</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_08</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_PLAY keytype: 33024 keycode: 280</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:280 and key type:33024 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_09</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_09</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_STOP keytype: 33024 keycode: 281</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:281 and key type:33024 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_10</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_10</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_PAUSE keytype: 33024 keycode: 282</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:282 and key type:33024 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_11</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_11</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_FASTFORWARD keytype: 33024 keycode: 283</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:283 and key type:33024 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_12</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_12</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_REWIND keytype: 33024 keycode: 284</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:284 and key type:33024 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_13</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_13</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_RECORD keytype: 33024 keycode: 285</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:285 and key type:33024 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_14</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_14</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_REPLAY keytype: 33024 keycode: 286</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:286 and key type:33024 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_15</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_15</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  RPT_PLAY keytype: 33280 keycode: 280</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:280 and key type:33280 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_16</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_16</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  RPT_STOP keytype: 33280 keycode: 281</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:281 and key type:33280 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_17</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_17</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_PAUSE keytype: 33280 keycode: 282</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:282 and key type:33280 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_18</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_18</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  RPT_FASTFORWARD keytype: 33280 keycode: 283</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:283 and key type:33280 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_19</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_19</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_REWIND keytype: 33280 keycode: 284</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:284 and key type:33280 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_20</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_20</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_RECORD keytype: 33280 keycode: 285</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:285 and key type:33280 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_PLAYBACK-AND-RECORDING_ITER_TC_21</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_PLAYBACK-AND-RECORDING_ITER_21</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_REPLAY keytype: 33280 keycode: 286</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:286 and key type:33280 combination are stored in IRkey_playback-and-recording_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_PLAYBACK-AND-RECORDING_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_POWER_ITER_TC01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_POWER_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_POWER keytype: 32768 keycode: 297</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:297 and key type:32768 combination are stored in IRkey_Power_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_POWER_ITER_TC02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_POWER_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_TVPOWER keytype: 32768 keycode: 297</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:297 and key type:32768 combination are stored in IRkey_Power_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_POWER_ITER_TC03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_POWER_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key: KU_POWER keytype: 33024 keycode: 297</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:297 and key type:33024 combination are stored in IRkey_Power_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_POWER_ITER_TC04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_POWER_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_TVPOWER keytype: 33024 keycode: 297</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:297 and key type:33024 combination are stored in IRkey_Power_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_POWER_ITER_TC05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_POWER_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_POWER keytype: 33280 keycode: 297</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:297 and key type:33280 combination are stored in IRkey_Power_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro39"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_POWER_ITER_TC06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_POWER_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_TVPOWER keytype: 33280 keycode: 297</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:297 and key type:33280 combination are stored in IRkey_Power_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_POWER_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_VOLUMECONTROLS_ITER_TC_01</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_VOLUMECONTROLS_ITER_01</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KD_VOLUMEUP keytype: 32768 keycode: 272</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:272 and key type:32768 combination are stored in IRkey_VolumeControls_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_VOLUMECONTROLS_ITER_TC_02</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_VOLUMECONTROLS_ITER_02</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KD_VOLUMEDOWN keytype: 32768 keycode: 273</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:273 and key type:32768 combination are stored in IRkey_VolumeControls_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_VOLUMECONTROLS_ITER_TC_03</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_VOLUMECONTROLS_ITER_03</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key-  KU_VOLUMEUP keytype: 33024 keycode: 272</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:272 and key type:33024 combination are stored in IRkey_VolumeControls_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_VOLUMECONTROLS_ITER_TC_04</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_VOLUMECONTROLS_ITER_04</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- KU_VOLUMEDOWN keytype: 33024 keycode: 273</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:273 and key type:33024 combination are stored inIRkey_VolumeControls_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_VOLUMECONTROLS_ITER_TC_05</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_VOLUMECONTROLS_ITER_05</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_VOLUMEUP keytype: 33280 keycode: 272</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:272 and key type:33280 combination are stored inIRkey_VolumeControls_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:142.7pt; " class="ce41"><p>IRKEY_VOLUMECONTROLS_ITER_TC_06</p></td><td style="text-align:left;width:142.7pt; " class="ce25"><p>TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:149.05pt; " class="ce25"><p>twc_IRKEY_VOLUMECONTROLS_ITER_06</p></td><td style="text-align:left;width:117.35pt; " class="ce25"><p>To check the response time for the key- RPT_VOLUMEDOWN keytype: 33280 keycode: 273</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>Positive</p></td><td style="text-align:left;width:50.29pt; " class="ce42"><p>HUMAX</p></td><td style="text-align:left;width:90.4pt; " class="ce25"><p>1)Agent should be up and running. Test script should be present in the location. </p></td><td style="text-align:left;width:215.66pt; " class="ce25"><p>1)Load IARMBUS module. Key code:273 and key type:33280 combination are stored inIRkey_VolumeControls_Iter.txt and read the values. </p><p>2)Initialise IARMBus by calling IARMBUS API "IARMBUS_Init".</p><p>3)Now connect Application to IARM-Bus Daemon by calling IARMBUS API "IARM_Bus_Connect".</p><p>4)Register Event Handler by calling IARMBUS API "IARM_Bus_RegisterEventHandler".Add parameter and value combination ("owner_name","IRMgr") ,("event_id",0) for IR key events.</p><p>5)Specify the appname as "gen_single_event".This app will run once and generate an IR event on the bus with keyType and keyCode by invoking IARMBUS API 'IARMBUS_InvokeEventTransmitterApp'.</p><p>6)Fetch response time by calling IARMBUS API 'IARMBUS_GetLastReceivedEventPerformanceDetails'.</p><p>7)Now unregister all the API's in the order as they are registered.</p><p>8)Repeat the steps 2 - 7 for 6 times.</p><p>9) Validate data and calculate mean of response time.</p><p>10)Unload IARMBUS module.</p></td><td style="text-align:left;width:93.54pt; " class="ce25"><p>Performance reading(Average respose time)</p></td><td style="text-align:left;width:175.21pt; " class="ce25"><p>twc_TWC_IRKEY_VOLUMECONTROLS_ITER</p></td><td style="text-align:left;width:50.29pt; " class="ce25"> </td><td style="text-align:left;width:84.05pt; " class="ce25"> </td><td style="text-align:right; width:79.31pt; " class="ce25"><p>5</p></td><td style="text-align:left;width:91.96pt; " class="ce25"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro43"><td style="text-align:left;width:50.29pt; " class="ce11"><p>Test Case ID</p></td><td style="text-align:left;width:142.7pt; " class="ce11"><p>Test Objective</p></td><td style="text-align:left;width:142.7pt; " class="ce11"><p>Test Type</p></td><td style="text-align:left;width:149.05pt; " class="ce11"><p>Test Setup</p></td><td style="text-align:left;width:117.35pt; " class="ce11"><p>API's / Interface Used</p></td><td style="text-align:left;width:50.29pt; " class="ce11"><p>Input Parameters</p><p>(<span class="T3">API name</span><span class="T4">: parameter type – value) / </span></p><p><span class="T5">Interface Input</span></p></td><td style="text-align:left;width:50.29pt; " class="ce11"><p>Pre-requisite</p></td><td style="text-align:left;width:90.4pt; " class="ce11"><p>Automation Approach</p></td><td style="text-align:left;width:215.66pt; " class="ce11"><p>Exp Output</p></td><td style="text-align:left;width:93.54pt; " class="ce11"><p>Test Stub Interface</p></td><td style="text-align:left;width:175.21pt; " class="ce11"><p>Test script</p></td><td style="text-align:left;width:50.29pt; " class="ce11"><p>Remarks</p></td><td style="text-align:left;width:84.05pt; " class="ce11"><p>Release version</p></td><td style="text-align:left;width:79.31pt; " class="ce43"> </td><td style="text-align:left;width:91.96pt; " class="ce43"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro44"><td colspan="13" style="text-align:left;width:50.29pt; " class="ce40"><p>Performance Tests</p></td><td style="text-align:left;width:79.31pt; " class="ce43"> </td><td style="text-align:left;width:91.96pt; " class="ce43"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:50.29pt; " class="ce2"><p>IARMBUS_PERF_1</p></td><td style="text-align:left;width:142.7pt; " class="ce2"><p>To get the response time  of single sender and multiple receiver</p></td><td style="text-align:left;width:142.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:149.05pt; " class="ce2"><p>HUMAX</p></td><td style="text-align:left;width:117.35pt; " class="ce19"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:50.29pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_IsConnected</span><span class="T7"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T6">IARMBUS_GetLastReceivedEventPerformanceDetails</span><span class="T9">: Average of response time.</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:50.29pt; " class="ce19"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:90.4pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For IARMBUS_GetLastReceivedEventPerformanceDetails API called in the script, IARMBUS_Agent will give the average of response time to Test Agent.</p><p> </p><p> </p></td><td style="text-align:left;width:215.66pt; " class="ce19"><p>Checkpoint 1.Check the return value of API.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:93.54pt; " class="ce19"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventPerformanceDetails</p></td><td style="text-align:left;width:175.21pt; " class="ce27"><p>IARMBUs_Multiple_Sender_Single_Receiver_Performance_Test</p></td><td style="text-align:left;width:50.29pt; " class="ce27"> </td><td style="text-align:left;width:84.05pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:79.31pt; " class="ce43"> </td><td style="text-align:left;width:91.96pt; " class="ce43"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:50.29pt; " class="ce2"><p>IARMBUS_PERF_2</p></td><td style="text-align:left;width:142.7pt; " class="ce2"><p>To get the  response time of Single IR Event PerformanceTest</p></td><td style="text-align:left;width:142.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:149.05pt; " class="ce2"><p>HUMAX</p></td><td style="text-align:left;width:117.35pt; " class="ce19"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:50.29pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_IsConnected</span><span class="T7"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T6">IARMBUS_GetLastReceivedEventPerformanceDetails</span><span class="T9">: Average of response time.</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:50.29pt; " class="ce19"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:90.4pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For IARMBUS_GetLastReceivedEventPerformanceDetails API called in the script, IARMBUS_Agent will give the average of response time to Test Agent.</p><p> </p><p> </p></td><td style="text-align:left;width:215.66pt; " class="ce19"><p>Checkpoint 1.Check the return value of API.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:93.54pt; " class="ce19"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventPerformanceDetails</p></td><td style="text-align:left;width:175.21pt; " class="ce27"><p>IARMBUS_Single_IREvent_PerformanceTest</p></td><td style="text-align:left;width:50.29pt; " class="ce27"> </td><td style="text-align:left;width:84.05pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:79.31pt; " class="ce43"> </td><td style="text-align:left;width:91.96pt; " class="ce43"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:50.29pt; " class="ce2"><p>IARMBUS_PERF_3</p></td><td style="text-align:left;width:142.7pt; " class="ce19"><p>To get the response time of Single Sender Multiple Receiver Test</p></td><td style="text-align:left;width:142.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:149.05pt; " class="ce2"><p>HUMAX</p></td><td style="text-align:left;width:117.35pt; " class="ce19"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:50.29pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_IsConnected</span><span class="T7"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T6">IARMBUS_GetLastReceivedEventPerformanceDetails</span><span class="T9">:  Average of response time.</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:50.29pt; " class="ce19"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:90.4pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For IARMBUS_GetLastReceivedEventPerformanceDetails API called in the script, IARMBUS_Agent will give  the average of response time to Test Agent.</p><p> </p><p> </p></td><td style="text-align:left;width:215.66pt; " class="ce19"><p>Checkpoint 1.Check the return value of API.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:93.54pt; " class="ce19"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventPerformanceDetails</p></td><td style="text-align:left;width:175.21pt; " class="ce27"><p>IARMBUS_Single_Sender_Multiple_Receiver_Test</p></td><td style="text-align:left;width:50.29pt; " class="ce27"> </td><td style="text-align:left;width:84.05pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:79.31pt; " class="ce43"> </td><td style="text-align:left;width:91.96pt; " class="ce43"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:50.29pt; " class="ce2"><p>IARMBUS_PERF_4</p></td><td style="text-align:left;width:142.7pt; " class="ce19"><p>To get the response time of Two Event Sender Two Event Receiver</p></td><td style="text-align:left;width:142.7pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:149.05pt; " class="ce2"><p>HUMAX</p></td><td style="text-align:left;width:117.35pt; " class="ce19"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:50.29pt; " class="ce20"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T6">IARM_Bus_Connect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_IsConnected</span><span class="T7"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T6">IARMBUS_GetLastReceivedEventPerformanceDetails</span><span class="T9">:  Average of response time.</span></p><p><span class="T6">IARM_Bus_Disconnect</span><span class="T7"> : None</span></p><p><span class="T6">IARM_Bus_Term</span><span class="T7"> : None</span></p></td><td style="text-align:left;width:50.29pt; " class="ce19"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:90.4pt; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For IARMBUS_GetLastReceivedEventPerformanceDetails API called in the script, IARMBUS_Agent will give the average of response time to Test Agent.</p><p> </p><p> </p></td><td style="text-align:left;width:215.66pt; " class="ce19"><p>Checkpoint 1.Check the return value of API.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:93.54pt; " class="ce19"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventPerformanceDetails</p></td><td style="text-align:left;width:175.21pt; " class="ce27"><p>IARMBUS_Two_Evt_Sender_Two_Evt_Receiver</p></td><td style="text-align:left;width:50.29pt; " class="ce27"> </td><td style="text-align:left;width:84.05pt; " class="ce35"><p>M23</p></td><td style="text-align:left;width:79.31pt; " class="ce43"> </td><td style="text-align:left;width:91.96pt; " class="ce43"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro40"><td style="text-align:left;width:50.29pt; " class="Default"> </td><td style="text-align:left;width:142.7pt; " class="ce9"> </td><td style="text-align:left;width:142.7pt; " class="ce9"> </td><td style="text-align:left;width:149.05pt; " class="ce9"> </td><td style="text-align:left;width:117.35pt; " class="ce9"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td><td style="text-align:left;width:90.4pt; " class="ce9"> </td><td style="text-align:left;width:215.66pt; " class="ce9"> </td><td style="text-align:left;width:93.54pt; " class="ce9"> </td><td style="text-align:left;width:175.21pt; " class="ce9"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td><td style="text-align:left;width:84.05pt; " class="ce9"> </td><td style="text-align:left;width:79.31pt; " class="ce9"> </td><td style="text-align:left;width:91.96pt; " class="ce9"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr><tr class="ro40"><td style="text-align:left;width:50.29pt; " class="Default"> </td><td style="text-align:left;width:142.7pt; " class="ce9"> </td><td style="text-align:left;width:142.7pt; " class="ce9"> </td><td style="text-align:left;width:149.05pt; " class="ce9"> </td><td style="text-align:left;width:117.35pt; " class="ce9"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td><td style="text-align:left;width:90.4pt; " class="ce9"> </td><td style="text-align:left;width:215.66pt; " class="ce9"> </td><td style="text-align:left;width:93.54pt; " class="ce9"> </td><td style="text-align:left;width:175.21pt; " class="ce9"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td><td style="text-align:left;width:84.05pt; " class="ce9"> </td><td style="text-align:left;width:79.31pt; " class="ce9"> </td><td style="text-align:left;width:91.96pt; " class="ce9"> </td><td style="text-align:left;width:50.29pt; " class="Default"> </td></tr></table></body></html>
