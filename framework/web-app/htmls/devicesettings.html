<?xml version="1.0" encoding="UTF-8"?>
<!--
 If not stated otherwise in this file or this component's Licenses.txt file the
 following copyright and licenses apply:

 Copyright 2016 RDK Management

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.contributor" content="Nampoothiri, Sreelal (Contractor)"/><meta name="DCTERMS.modified" content="2016-05-02T19:24:57" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.Default { font-family:Arial; padding:2.01pt; }
	.ce1 { background-color:#558ed5; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce10 { background-color:#b3b3b3; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce11 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce12 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce13 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce14 { padding:2.01pt; font-family:Arial; background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce15 { padding:2.01pt; font-family:Arial; background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce16 { padding:2.01pt; font-family:Arial; background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce17 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce18 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; }
	.ce19 { padding:2.01pt; font-family:Arial; background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce2 { background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:13pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce20 { padding:2.01pt; font-family:Arial; background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce21 { padding:2.01pt; font-family:Arial; background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce22 { padding:2.01pt; font-family:Arial; background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce23 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce24 { background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce25 { padding:2.01pt; font-family:Arial; background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; }
	.ce26 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce27 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:justify ! important; }
	.ce28 { background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce29 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; color:#0000ff; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce3 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce30 { padding:2.01pt; font-family:Arial; background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#0000ff; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce31 { background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce32 { background-color:#b3b3b3; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce33 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce34 { padding:2.01pt; font-family:Arial; background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce35 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce36 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; }
	.ce37 { padding:2.01pt; font-family:Times New Roman; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; color:#0000ff; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce38 { padding:2.01pt; font-family:Times New Roman; background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; color:#0000ff; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce39 { padding:2.01pt; font-family:Times New Roman; background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0pt; writing-mode:page; color:#0000ff; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce4 { background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce40 { background-color:#cccccc; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce41 { background-color:transparent; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce42 { padding:2.01pt; font-family:Arial; background-color:#cccccc; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce43 { padding:2.01pt; font-family:Arial; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce44 { padding:2.01pt; font-family:Arial; }
	.ce5 { background-color:#b3b3b3; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce6 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce7 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce8 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce9 { padding:2.01pt; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.co1 { width:122.91pt; }
	.co10 { width:58.65pt; }
	.co11 { width:132.41pt; }
	.co12 { width:273.54pt; }
	.co13 { width:64.2pt; }
	.co2 { width:128.44pt; }
	.co3 { width:44.39pt; }
	.co4 { width:75.29pt; }
	.co5 { width:148.25pt; }
	.co6 { width:71.35pt; }
	.co7 { width:127.64pt; }
	.co8 { width:175.21pt; }
	.co9 { width:99.89pt; }
	.ro1 { height:43.91pt; }
	.ro10 { height:191.25pt; }
	.ro11 { height:229.49pt; }
	.ro12 { height:12.76pt; }
	.ro13 { height:242.25pt; }
	.ro14 { height:20.1pt; }
	.ro15 { height:255pt; }
	.ro16 { height:127.5pt; }
	.ro17 { height:88.16pt; }
	.ro18 { height:16.5pt; }
	.ro19 { height:280.49pt; }
	.ro2 { height:24.6pt; }
	.ro20 { height:281.99pt; }
	.ro21 { height:256.51pt; }
	.ro22 { height:231pt; }
	.ro23 { height:243.75pt; }
	.ro24 { height:205.51pt; }
	.ro25 { height:192.76pt; }
	.ro26 { height:318.76pt; }
	.ro27 { height:344.24pt; }
	.ro28 { height:293.24pt; }
	.ro29 { height:334.49pt; }
	.ro3 { height:229.86pt; }
	.ro30 { height:320.26pt; }
	.ro31 { height:307.5pt; }
	.ro32 { height:357pt; }
	.ro33 { height:114.75pt; }
	.ro34 { height:178.5pt; }
	.ro35 { height:140.26pt; }
	.ro36 { height:101.99pt; }
	.ro37 { height:12.76pt; }
	.ro4 { height:216.74pt; }
	.ro5 { height:204.01pt; }
	.ro6 { height:306pt; }
	.ro7 { height:165.74pt; }
	.ro8 { height:20.86pt; }
	.ro9 { height:153.01pt; }
	.T1 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T10 { color:#0000ff; font-family:Times New Roman; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T11 { font-family:Times New Roman; font-size:12pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.T2 { font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T3 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; text-decoration:underline; font-style:normal; text-shadow:none; }
	.T4 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; font-style:normal; text-shadow:none; text-decoration:none ! important; }
	.T5 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T6 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:underline; font-style:normal; text-shadow:none; }
	.T7 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; font-style:normal; text-shadow:none; text-decoration:none ! important; }
	.T8 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T9 { color:#000000; font-family:Arial; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="margin-top:56.69pt; margin-bottom:56.69pt; margin-left:56.69pt; margin-right:56.69pt; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="189"/><col width="198"/><col width="68"/><col width="116"/><col width="229"/><col width="110"/><col width="197"/><col width="270"/><col width="154"/><col width="90"/><col width="204"/><col width="422"/><col width="99"/><col width="99"/></colgroup><tr class="ro1"><td style="text-align:left;width:122.91pt; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:128.44pt; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:44.39pt; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:75.29pt; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:148.25pt; " class="ce1"><p>API's / Interface Used</p></td><td style="text-align:left;width:71.35pt; " class="ce1"><p>Input Parameters</p><p>(<span class="T3">API name</span><span class="T4">: parameter type – value) / </span></p><p><span class="T5">Interface Input</span></p></td><td style="text-align:left;width:127.64pt; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:175.21pt; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:99.89pt; " class="ce1"><p>Exp Output</p></td><td style="text-align:left;width:58.65pt; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:132.41pt; " class="ce1"><p>Test Stub</p></td><td style="text-align:left;width:273.54pt; " class="ce1"><p>Test script</p></td><td style="text-align:left;width:64.2pt; " class="ce1"><p>Remarks</p></td><td style="text-align:left;width:64.2pt; " class="ce1"><p>Release version</p></td></tr><tr class="ro2"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Front Panel API</p></td><td style="text-align:left;width:64.2pt; " class="ce40"> </td></tr><tr class="ro3"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_1</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set brightness for front panel Indicator</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelIndicator::getInstance()</p><p>FrontPanelIndicator::getIndicators()</p><p>FrontPanelIndicator::getIndicator(string)</p><p>FrontPanelIndicator::getBrightness() </p><p>FrontPanelIndicator::setBrightness(int)                  device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string  - name</span></p><p><span class="T1">E.g.: name: “POWER” </span></p><p><span class="T6">SetBrightness</span><span class="T7"> : int - brightness </span></p><p><span class="T1">E.g.: Range 0 to 100</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of Indicators.</p><p>3.Device_Settings_Agent will get the indicators by passing the “name: POWER”</p><p>4.Device_Settings_Agent will get the value of brightness for POWER Indicator.</p><p>5.Device_Settings_Agent will set the brightness value to “brightness” for the POWER Indicator.</p><p>6.TM makes RPC calls for getting the POWER Indicator brightness value from Device_Settings_Agent and verify whether the brightness has changed.</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the value of POWER Indicator brightness after and before setting the value of brightness.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_getIndicators</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBrightness test_01</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce3"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_2</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the POWER LED</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “POWER”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 0,1,2,3,4,5</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6. TM makes RPC calls for getting the color of POWER Indicator from Device Settings_stub and verify whether the color has changed.</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetColor test_02</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce33"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_3</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the blink value of the POWER LED</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::setBlink(int)</p><p>FrontPanelConfig::getBlink()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name </span></p><p><span class="T1">Eg:name: “POWER”</span></p><p><span class="T6">setBlink</span><span class="T7"> : int – blink</span></p><p><span class="T1">E.g.: 1,2</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get Blink interval of front panel indicator LED.</p><p>3.Device_Settings_Agent will set Blink interval to “blink ” of front panel indicator LED.</p><p>4.Device_Settings_Agent will get  Blink interval of front panel indicator LED.</p><p>5.TM compares the Blink Interval before and after setting the Interval and returns SUCCESS or FAILURE status to Test Agent .</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the blink value of POWER Indicator after and before setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setBlink</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBlink test_03</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro6"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_4</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the Time format/Text of the Text display</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce11"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p><span class="T1">FrontPanelConfig::getTextDisplays ()      </span></p><p><span class="T2">FrontPanelConfig::getTextDisplay(string)</span></p><p><span class="T2">FrontPanelConfig::setText()</span></p><p><span class="T2">FrontPanelConfig::getCurrentTimeForamt() </span></p><p><span class="T2">FrontPanelConfig::setTimeFormat(int)</span></p><p><span class="T2">FrontPanelConfig::setTime()</span></p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getTextDisplay<span class="T1"> : string – name </span></p><p><span class="T1">name:“TEXT” </span></p><p><span class="T6">setTimeFormat</span><span class="T7"> : int id </span></p><p><span class="T1">E.g.: id: 0,1,2</span></p><p><span class="T1">SetTime : int – hrs, int – mins</span></p><p><span class="T1">SetText : string- text</span></p><p><span class="T1">E.g.: text: “hello”</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of test display panel in the front Panel.</p><p>3.Device_Settings_Agent will get a instance for single test display panel by “passing name:TEXT”</p><p>4.Device_Settings_Agent will set some text in the text display panel of front panel indicator.</p><p>5.Device_Settings_Agent will get the Time format displayed in the front panel </p><p>6.Device_Settings_Agent will get Time format in the front panel.</p><p>7Device_Settings_Agent will set a new time by passing “hrs” and “mins” value.</p><p>8.TM makes RPC calls for getting the Time format from Device_Settings_Agent and verify whether the format has changed.</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the Time format in the Front panel after and before setting the format.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the return value of setTime &amp; setText APIs.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setText</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p>TestMgr_DS_FP_getTextDisplays</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SeTimeFormat_and_Time test_04</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_5</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the  information for scroll</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                 FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getTextDisplay(String)</p><p>FrontPanelConfig::getScroll();</p><p>FrontPanelConfig::setScroll(Scroll);</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getTextDisplay<span class="T1"> : string  “TEXT”  </span></p><p><span class="T6">SetScroll</span><span class="T7"> : Scroll - object for Scroll class</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get scroll details.</p><p>3.Device_Settings_Agent will set scroll details to “Scroll object”.</p><p>4.Device_Settings_Agent will get scroll details.</p><p>5.TM compares the scroll details(iteration and duration) before and after setting the value of iteration and duration.</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the scroll value of Text Display before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setScroll</p><p>TestMgr_DS_managerDeinitialize</p><p> </p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetScroll test_05</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro8"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Audio Output Port API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_6</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the audio level</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p> </p><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setLevel(float)</p><p>AudioOutputPort::getLevel();</p><p>device::Manager::DeInitialize()</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetLevel: float – newLevel</p><p>Eg:2.0</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio level. </p><p>3.Device_Settings_Agent will set audio level to “newLevel”.</p><p>4. Device_Settings_Agent will get audio level.</p><p>5.TM compares the audio level  before and after setting the value of level.</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio level before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setLevel</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetAudioLevel test_06</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro10"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_7</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the db value to be used in a given audio port and get the maximum and minimum db level that can be supported by the port.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setDB(float);</p><p>AudioOutputPort::getDB();</p><p>AudioOutputPort::getMaxDB()</p><p>AudioOutputPort::getMinDB()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetDB: int – newDb</p><p>Eg:1.0</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio db level used in audio output port. </p><p>3.Device_Settings_Agent will set audio db level used in audio output port to “newDb”. </p><p>4.Device_Settings_Agent will get audio db level used in audio output port. </p><p>5.TM compares the audio level  before and after setting the value of db.</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio db value before and after setting the value.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setDB</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDB test_07</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro10"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_8</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – checking whether the given audio port is configured for loop thro'.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setLoopThru(bool);</p><p>AudioOutputPort::IsLoopThru();</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setLoopThru: bool - loopthru</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will check for the status of Loop thru functionality.</p><p>3. Device_Settings_Agent will set LoopThru functionality of audio port to “loopthru”.</p><p>4. Device_Settings_Agent will check for the status of Loop thru functionality of audio port and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the status of LoopThru before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_loopThru</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_LoopThru test_08</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_9</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Checking for audio MUTE.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setMuted(bool);</p><p>AudioOutputPort::IsMuted();</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setMuted: bool - mute</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will check for the status of audio mute status.</p><p>3. Device_Settings_Agent will enable/disable audio mute status of audio port.</p><p>4. Device_Settings_Agent will check for the status of audio mute and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the status of audio mute before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_mutedStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_mute_test_09</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_10</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  encoding formats.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedEncodings()</p><p>AudioOutputPort::getEncoding()</p><p>AudioOutputPort::setEncoding(int)</p><p>AudioOutputPort::setEncoding(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>setEncoding<span class="T1"> : string</span></p><p><span class="T1">E.g.: AC3</span></p><p><span class="T6">setEncoding</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 0,1</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported encoding formats.</p><p>3.Device_Settings_Agent will get the current encoding format.</p><p>4.Device_Settings_Agent will set new encoding format.</p><p>5.Device_Settings_Agent will get the current encoding format.</p><p>6.Device_Settings_Agent will check the current encoding format with new encoding format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the encoding format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedEncodings</p><p>TestMgr_DS_AOP_setEncoding</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetEncoding test_10</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_11</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  compression formats.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedCompression()</p><p>AudioOutputPort::getCompression()</p><p>AudioOutputPort::setCompression(int)</p><p>AudioOutputPort::setCompression(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>SetCompression<span class="T1"> : string</span></p><p><span class="T1">E.g.: MEDIUM</span></p><p><span class="T6">SetCompression</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 0,1</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported compression formats.</p><p>3.Device_Settings_Agent will get the current compression format.</p><p>4.Device_Settings_Agent will set new compression format.</p><p>5.Device_Settings_Agent will get the current compression format.</p><p>6.Device_Settings_Agent will check the current compression format with new compression format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the compression format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedCompressions</p><p>TestMgr_DS_AOP_setCompression</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetCompression test_11</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_12</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set stereo formats.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(int)</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: SURROUND</span></p><p><span class="T6">setStereoMode</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 0,1</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetStereoModes test_12</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro12"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Host API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro13"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_13</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – Adding and Removing Listeners for Power mode change.</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::setPowerMode(int)</p><p>Host::getPowerMode()</p><p>Host::addPowerModeListener()</p><p>Host::removePowerModeListener()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setPowerMode : int </p><p>E.g.: 0,1</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will add listener for power mode change.</p><p>3.Device_Settings_Agent will check for the power state of STB.</p><p>4.Device_Settings_Agent will set the desired power state of STB.</p><p>5.Device_Settings_Agent will remove listener for power mode change.</p><p>6.Device_Settings_Agent will set the desired power state of STB.</p><p>7.Device_Settings_Agent will check for the state of STB and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the power state of STB before and after setting it.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the log message before and after removing power mode change Listener.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_addPowerModeListener</p><p>TestMgr_DS_HOST_setPowerMode</p><p>TestMgr_DS_HOST_removePowerModeListener</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_PowerMode Listener test_13</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>Power Mode API is invalid in future releases</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_14</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Adding and Removing Listeners for display connection change.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>VideoOutputPort::isDisplayConnected()</p><p>Host::addDisplayConnectionListener()</p><p>Host::removeDisplayConnectionListener()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"> </td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will add listener for display connection change.</p><p>3.Device_Settings_Agent will check for the display connection status.</p><p>4.Device_Settings_Agent will remove listener for display connection.</p><p>5.Device_Settings_Agent will set the display connection.</p><p>6.Device_Settings_Agent will check for the state of STB and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check for the log message before and after removing display connection Listener.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_addDisplayConnectionListener</p><p>TestMgr_DS_HOST_removeDisplayConnectionListener</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_AddDisplayconnection Listener test_14</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro12"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Video Device API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_15</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display video device mode(Zoom) for the video device.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setDFC : int -Id</p><p>setDFC : String -</p><p>E.g.: Full , Platform, None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDFC test_15</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro14"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Video Output Port API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_16</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution settings.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 480i,720p,1080i</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution test_16</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_17</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  check for Content Protection status in the port.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::isContentProtected()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will check for content protection support(either true/false) for the given port</p><p>3.Device_Settings_Agent will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the  content protection support for the given port.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_isContentProtected</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_IsContentProtection test_17</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce5"><p>CT_DS_18</p></td><td style="text-align:left;width:128.44pt; " class="ce10"><p>Device Setting –  check for HDCP support for the given port.</p></td><td style="text-align:left;width:44.39pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce5"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce5"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::isHDCPSupported()</p><p>VideoOutputPortType::enabledHDCP()</p><p>Device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce5"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce5"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce5"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will check for  HDCP protection support(either true/false) for the given port.</p><p>3.Device_Settings_Agent will enable HDCP feature for the given port.</p><p>4.Device_Settings_Agent will check for the status of HDCP in the port and it will return SUCCESS or FAILURE based on the result.</p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce32"><p>Checkpoint 1.<span class="T1"> Check the HDCP support  for the given port.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce5"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce5"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_HDCPSupport</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce5"><p>DS_HDCP Support test_18</p></td><td style="text-align:left;width:64.2pt; " class="ce5"> </td><td style="text-align:left;width:64.2pt; " class="ce5"><p>M21</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_18</p></td><td style="text-align:left;width:128.44pt; " class="ce11"><p>Device Setting –  Check if HDCP is supported for the given HDMI port.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::isHDTPSupported()</p><p>VideoOutputPortType::enabledHDCP()</p><p>Device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will check for  HDCP protection support(either true/false) for the given port.</p><p>3.Device_Settings_Agent will check for the status of HDCP in the port and it will return SUCCESS or FAILURE based on the result.</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if the API is executed successfully.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_isHDCPSupported</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_IsHDCPSupported_test_18</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce6"><p>CT_DS_19</p></td><td style="text-align:left;width:128.44pt; " class="ce11"><p>Device Setting –  check for DTCP support for the given port.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::isDTCPSupported()</p><p>VideoOutputPortType::enabledDTCP()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will check for  DTCP protection support(either true/false) for the given port.</p><p>3.Device_Settings_Agent will enable DTCP feature for the given port.</p><p>4.Device_Settings_Agent will check for the status of DTCP in the port and it will return SUCCESS or FAILURE based on the result.</p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the DTCP support  for the given port.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_DTCPSupport</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_DTCP support test_19</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M24</p></td></tr><tr class="ro17"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_20</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Checking for DynamicResolutionSupport for the given port.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::isDynamicResolutionSupported()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will check for  DynamicResolution support(either true/false) for the video port.</p><p>3.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(2nd). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the DynamicResolution support  for the given port.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_isDynamicResolutionSupported</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_IsDynamicResolutionsSupport test_20</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_21</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Checking the current Aspect Ratio  with available Aspect Ratio formats. </p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::Display::getAspectRatio()</p><p>VideoOutputPort::isDisplayConnected()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the current Aspect Ratio.</p><p>3.Device_Settings_Agent will check for the current aspect Ratio with the list of available aspect Ratio formats.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(3rd). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current aspect Ratio present in the list of available aspect Ratio formats.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_isDisplayConnected</p><p>TestMgr_DS_VOP_getAspectRatio</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_GetAspect Ratio test_21</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro10"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_22</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Listing display details.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::getDisplay()</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getManufacturerWeek()</p><p>VideoOutputPort::getManufacturerYear()</p><p>VideoOutputPort::getProductCode()</p><p>VideoOutputPort::getSerialNumber()</p><p>device::Manager::DeInitialize()</p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce31"><p>1.TM loads the Device_Settings_Agent via the test agent </p><p> </p><p>2.Device_Settings_Agent will list the details about videoOutputPort.</p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1<span class="T1"> Check for return value of the APIs</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_isDisplayConnected</p><p>TestMgr_DS_VOP_getDisplayDetails</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_GetDisplayDetails test_22</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro18"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"> </td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro18"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Front Panel API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro19"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_23</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set brightness for front panel Indicator with Minimum value</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelIndicator::getInstance()</p><p>FrontPanelIndicator::getIndicators()</p><p>FrontPanelIndicator::getIndicator(string)</p><p>FrontPanelIndicator::getBrightness() </p><p>FrontPanelIndicator::setBrightness(int)                  device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string  - name</span></p><p><span class="T1">E.g.: name: “POWER” </span></p><p><span class="T6">SetBrightness</span><span class="T7"> : int - brightness </span></p><p><span class="T1">E.g.: Value is  0. </span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of Indicators.</p><p>3.Device_Settings_Agent will get the indicators by passing the “name: POWER”</p><p>4.Device_Settings_Agent will get the value of brightness for POWER Indicator.</p><p>5.Device_Settings_Agent will set the brightness value to “brightness” for the POWER Indicator.</p><p>6.TM makes RPC calls for getting the POWER Indicator brightness value from Device_Settings_Agent and verify whether the brightness has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6th)</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the value of POWER Indicator brightness after and before setting the value of brightness.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_getIndicators</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBrightness_Minimum value test_23</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro19"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_24</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set brightness for front panel Indicator with Maximum value.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelIndicator::getInstance()</p><p>FrontPanelIndicator::getIndicators()</p><p>FrontPanelIndicator::getIndicator(string)</p><p>FrontPanelIndicator::getBrightness() </p><p>FrontPanelIndicator::setBrightness(int)                  device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string  - name</span></p><p><span class="T1">E.g.: name: “POWER” </span></p><p><span class="T6">SetBrightness</span><span class="T7"> : int - brightness </span></p><p><span class="T1">E.g.: Value is  100. </span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of Indicators.</p><p>3.Device_Settings_Agent will get the indicators by passing the “name: POWER”</p><p>4.Device_Settings_Agent will get the value of brightness for POWER Indicator.</p><p>5.Device_Settings_Agent will set the brightness value to “brightness” for the POWER Indicator.</p><p>6.TM makes RPC calls for getting the POWER Indicator brightness value from Device_Settings_Agent and verify whether the brightness has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6th)</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the value of POWER Indicator brightness after and before setting the value of brightness.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_getIndicators</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBrightness_Maximum value test_24</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro19"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_25</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set brightness for front panel Indicator within valid range.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelIndicator::getInstance()</p><p>FrontPanelIndicator::getIndicators()</p><p>FrontPanelIndicator::getIndicator(string)</p><p>FrontPanelIndicator::getBrightness() </p><p>FrontPanelIndicator::setBrightness(int)                  device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string  - name</span></p><p><span class="T1">E.g.: name: “POWER” </span></p><p><span class="T6">SetBrightness</span><span class="T7"> : int - brightness </span></p><p><span class="T1">E.g.: Range 0 to 100.. </span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of Indicators.</p><p>3.Device_Settings_Agent will get the indicators by passing the “name: POWER”</p><p>4.Device_Settings_Agent will get the value of brightness for POWER Indicator.</p><p>5.Device_Settings_Agent will set the brightness value to “brightness” for the POWER Indicator.</p><p>6.TM makes RPC calls for getting the POWER Indicator brightness value from Device_Settings_Agent and verify whether the brightness has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6th)</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the value of POWER Indicator brightness after and before setting the value of brightness.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_getIndicators</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBrightness_value in range test_25</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro20"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_26</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set brightness for front panel Indicator with negative value.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelIndicator::getInstance()</p><p>FrontPanelIndicator::getIndicators()</p><p>FrontPanelIndicator::getIndicator(string)</p><p>FrontPanelIndicator::getBrightness() </p><p>FrontPanelIndicator::setBrightness(int)                  device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string  - name</span></p><p><span class="T1">E.g.: name: “POWER” </span></p><p><span class="T6">SetBrightness</span><span class="T7"> : int - brightness </span></p><p><span class="T1">E.g.: Value is -50.</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of Indicators.</p><p>3.Device_Settings_Agent will get the indicators by passing the “name: POWER”</p><p>4.Device_Settings_Agent will get the value of brightness for POWER Indicator.</p><p>5.Device_Settings_Agent will set the brightness value to “brightness” for the POWER Indicator.</p><p>6.TM makes RPC calls for getting the POWER Indicator brightness value from Device_Settings_Agent and verify whether the brightness has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the value of POWER Indicator brightness after and before setting the value of brightness.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_getIndicators</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBrightness_value out of range test_26</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_27</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the MESSAGE LED to BLUE color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “MESSAGE”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:MESSAGE”.</p><p>4.Device_Settings_Agent will get the color for MESSAGE Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the MESSAGE Indicator.</p><p>6. TM makes RPC calls for getting the color of MESSAGE Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetblueColor_MESSAGE_LED_27</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_28</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the RECORD LED to BLUE color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “RECORD”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:RECORD”.</p><p>4.Device_Settings_Agent will get the color for RECORD Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the RECORD Indicator.</p><p>6. TM makes RPC calls for getting the color of RECORD Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetblueColor_RECORD_LED_28</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_29</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the RFBYPASS LED to BLUE color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “RFBYPASS”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:”RFBYPASS”.</p><p>4.Device_Settings_Agent will get the color for RFBYPASS Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the RFBYPASS Indicator.</p><p>6. TM makes RPC calls for getting the color of RFBYPASS Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetblueColor_RFBYPASS_LED_29</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_30</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the REMOTE LED to BLUE color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “REMOTE”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:REMOTE”.</p><p>4.Device_Settings_Agent will get the color for REMOTE Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the REMOTE Indicator.</p><p>6. TM makes RPC calls for getting the color of REMOTE Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetblueColor_REMOTE_LED_30</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_31</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the POWER LED to BLUE color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “POWER”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6. TM makes RPC calls for getting the color of POWER Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetblueColor_POWER_LED_31</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_32</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color for an invalid indicator.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “INVALID”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6. TM makes RPC calls for getting the color of POWER Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the error as the 'INVALID"Indicator provided is not present</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetblueColor_INVALID_LED_32</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_33</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the POWER LED to GREEN color</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “POWER”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 1</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6. TM makes RPC calls for getting the color of POWER Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetColor_green test_33</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_34</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the POWER LED to RED color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “POWER”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 2</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6. TM makes RPC calls for getting the color of POWER Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetColor_red test_34</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_35</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the POWER LED to YELLOW color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “POWER”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 3.</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6. TM makes RPC calls for getting the color of POWER Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetColor_yellow test_35</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_36</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the POWER LED to ORANGE color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “POWER”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 4.</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6. TM makes RPC calls for getting the color of POWER Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetColor_orange test_36</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro21"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_37</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the POWER LED to INVALID color.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “POWER”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 10</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6. TM makes RPC calls for getting the color of POWER Indicator from Device Settings_stub and verify whether the color has changed.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(6<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetColor_invalid_test_37</p></td><td style="text-align:left;width:64.2pt; " class="ce3"><p>Agent Crash</p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_38</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the blink value of the POWER LED</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::setBlink(int)</p><p>FrontPanelConfig::getBlink()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name </span></p><p><span class="T1">Eg:name: “POWER”</span></p><p><span class="T6">setBlink</span><span class="T7"> : int – blink</span></p><p><span class="T1">E.g.: 1,2</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get Blink interval of front panel indicator LED.</p><p>3.Device_Settings_Agent will set Blink interval to “blink ” of front panel indicator LED.</p><p>4.Device_Settings_Agent will get  Blink interval of front panel indicator LED.</p><p>5.TM compares the Blink Interval before and after setting the Interval and returns SUCCESS or FAILURE status to Test Agent .</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the blink value of POWER Indicator after and before setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setBlink</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBlink_valid_test_38</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_39</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the blink value of the POWER LED with negative input</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::setBlink(int)</p><p>FrontPanelConfig::getBlink()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name </span></p><p><span class="T1">Eg:name: “POWER”</span></p><p><span class="T6">setBlink</span><span class="T7"> : int – blink</span></p><p><span class="T1">E.g.: -1,-2</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get Blink interval of front panel indicator LED.</p><p>3.Device_Settings_Agent will set Blink interval to “blink ” of front panel indicator LED.</p><p>4.Device_Settings_Agent will get  Blink interval of front panel indicator LED.</p><p>5.TM compares the Blink Interval before and after setting the Interval and returns SUCCESS or FAILURE status to Test Agent .</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the error in setting blink value of POWER Indicator for invalid value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setBlink</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBlink_Invalid_test_39</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_40</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – Get and Set the blink value of the POWER LED with positive invalid  input</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::setBlink(int)</p><p>FrontPanelConfig::getBlink()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce28"><p>getIndicator<span class="T1"> : string – name </span></p><p><span class="T1">Eg:name: “POWER”</span></p><p><span class="T6">setBlink</span><span class="T7"> : int – blink</span></p><p><span class="T1">E.g.: 20.10</span></p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get Blink interval of front panel indicator LED.</p><p>3.Device_Settings_Agent will set Blink interval to “blink ” of front panel indicator LED.</p><p>4.Device_Settings_Agent will get  Blink interval of front panel indicator LED.</p><p>5.TM compares the Blink Interval before and after setting the Interval and returns SUCCESS or FAILURE status to Test Agent .</p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p> </p><p>Checkpoint 1<span class="T1">.Check for the error in setting blink value of POWER Indicator for invalid value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setBlink</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetBlink_outofrange_test_40</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>Agent Crash Invalid scenario</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_41</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the Time format in 12 hour format.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce11"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getCurrentTimeForamt() </p><p>FrontPanelConfig::setTimeFormat(int)</p><p>FrontPanelConfig::setTime()</p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p> </p><p>setTimeFormat<span class="T1"> : int id </span></p><p><span class="T1">E.g.: id: 0.</span></p><p><span class="T1">SetTime : int – hrs, int – mins</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the Time format displayed in the front panel </p><p>3.Device_Settings_Agent will get Time format in the front panel.</p><p>4.Device_Settings_Agent will set a new time by passing “hrs” and “mins” value.</p><p>5.TM makes RPC calls for getting the Time format from Device_Settings_Agent and verify whether the format has changed.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step5th).</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the Time format in the Front panel after and before setting the format.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the return value of setTime </span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p> </p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetTime_12HR_FORMAT_41</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_42</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the Time format in 24 hour format.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce11"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getCurrentTimeForamt() </p><p>FrontPanelConfig::setTimeFormat(int)</p><p>FrontPanelConfig::setTime()</p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p> </p><p>setTimeFormat<span class="T1"> : int id </span></p><p><span class="T1">E.g.: id: 1</span></p><p><span class="T1">SetTime : int – hrs, int – mins</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the Time format displayed in the front panel </p><p>3.Device_Settings_Agent will get Time format in the front panel.</p><p>4.Device_Settings_Agent will set a new time by passing “hrs” and “mins” value.</p><p>5.TM makes RPC calls for getting the Time format from Device_Settings_Agent and verify whether the format has changed.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th).</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the Time format in the Front panel after and before setting the format.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the return value of setTime </span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p> </p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetTime_24HR_FORMAT_42</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_43</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – Get and Set the Time format in string format.</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce24"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getCurrentTimeForamt() </p><p>FrontPanelConfig::setTimeFormat(int)</p><p>FrontPanelConfig::setTime()</p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce28"><p> </p><p>setTimeFormat<span class="T1"> : int id </span></p><p><span class="T1">E.g.: id: 2.</span></p><p><span class="T1">SetTime : int – hrs, int – mins</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the Time format displayed in the front panel </p><p>3.Device_Settings_Agent will get Time format in the front panel.</p><p>4.Device_Settings_Agent will set a new time by passing “hrs” and “mins” value.</p><p>5.TM makes RPC calls for getting the Time format from Device_Settings_Agent and verify whether the format has changed.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th).</p></td><td style="text-align:left;width:99.89pt; " class="ce4"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the Time format in the Front panel after and before setting the format.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the return value of setTime </span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p> </p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetTime_STRING_FORMAT_43</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>time format not supported</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro22"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_44</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – Get and Set the Time format by passing invalid value.</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce24"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getCurrentTimeForamt() </p><p>FrontPanelConfig::setTimeFormat(int)</p><p>FrontPanelConfig::setTime()</p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce28"><p> </p><p>setTimeFormat<span class="T1"> : int id </span></p><p><span class="T1">E.g.: id: 5.</span></p><p><span class="T1">SetTime : int – hrs, int – mins</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the Time format displayed in the front panel </p><p>3.Device_Settings_Agent will get Time format in the front panel.</p><p>4.Device_Settings_Agent will set a new time by passing “hrs” and “mins” value.</p><p>5.TM makes RPC calls for getting the Time format from Device_Settings_Agent and verify whether the format has changed.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce4"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the Time format in the Front panel after and before setting the format.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the return value of setTime </span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p> </p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetTime_INVALID_FORMAT_44</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>time format not supported</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro22"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_45</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the Time by passing invalid value.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce11"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getCurrentTimeForamt() </p><p>FrontPanelConfig::setTimeFormat(int)</p><p>FrontPanelConfig::setTime()</p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p> </p><p>setTimeFormat<span class="T1"> : int id </span></p><p><span class="T1">E.g.: id: 5.</span></p><p><span class="T1">SetTime : int – hrs, int – mins</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the Time format displayed in the front panel </p><p>3.Device_Settings_Agent will get Time format in the front panel.</p><p>4.Device_Settings_Agent will set a new time by passing “hrs” and “mins” value.</p><p>5.TM makes RPC calls for getting the Time format from Device_Settings_Agent and verify whether the format has changed.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the Time format in the Front panel after and before setting the format.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the return value of setTime </span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p> </p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetTime_INVALID_45</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro23"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_46</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the Text of the Text display</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce11"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p><span class="T1">FrontPanelConfig::getTextDisplays ()      </span></p><p><span class="T2">FrontPanelConfig::getTextDisplay(string)</span></p><p><span class="T2">FrontPanelConfig::setText()</span></p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getTextDisplay<span class="T1"> : string – name </span></p><p><span class="T1">name:“TEXT” </span></p><p><span class="T1">SetText : string- text</span></p><p><span class="T1">E.g.: text: “hello”</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of test display panel in the front Panel.</p><p>3.Device_Settings_Agent will get a instance for single test display panel by “passing name:TEXT”</p><p>4.Device_Settings_Agent will set some text in the text display panel of front panel indicator.</p><p>5.TM makes RPC calls for getting the Time format from Device_Settings_Agent and verify whether the format has changed.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check for the return value of setText APIs.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setText</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p>TestMgr_DS_FP_getTextDisplays</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetTextDisplay_test_46</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_48</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the  information for scroll with minimum Viteration,Hiteration &amp; hold_duration.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                 FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getTextDisplay(String)</p><p>FrontPanelConfig::getScroll();</p><p>FrontPanelConfig::setScroll(Scroll);</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getTextDisplay<span class="T1"> : string  “TEXT”  </span></p><p><span class="T6">SetScroll</span><span class="T7"> : Scroll - object for Scroll class</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get scroll details.</p><p>3.Device_Settings_Agent will set scroll details to “Scroll object”.</p><p>4.Device_Settings_Agent will get scroll details.</p><p>5.TM compares the scroll details(iteration and duration) before and after setting the value of iteration and duration.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th)</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the scroll value of Text Display before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setScroll</p><p>TestMgr_DS_managerDeinitialize</p><p> </p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetScroll_Minimum_Value_test_48</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_49</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the  information for scroll with maximum Viteration,Hiteration &amp; hold_duration.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                 FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getTextDisplay(String)</p><p>FrontPanelConfig::getScroll();</p><p>FrontPanelConfig::setScroll(Scroll);</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getTextDisplay<span class="T1"> : string  “TEXT”  </span></p><p><span class="T6">SetScroll</span><span class="T7"> : Scroll - object for Scroll class</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get scroll details.</p><p>3.Device_Settings_Agent will set scroll details to “Scroll object”.</p><p>4.Device_Settings_Agent will get scroll details.</p><p>5.TM compares the scroll details(iteration and duration) before and after setting the value of iteration and duration.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th)</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the scroll value of Text Display before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setScroll</p><p>TestMgr_DS_managerDeinitialize</p><p> </p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetScroll_Maximum_Value_test_49</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro24"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_50</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the  information for scroll with middle value Viteration,Hiteration &amp; hold_duration.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                 FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getTextDisplay(String)</p><p>FrontPanelConfig::getScroll();</p><p>FrontPanelConfig::setScroll(Scroll);</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getTextDisplay<span class="T1"> : string  “TEXT”  </span></p><p><span class="T6">SetScroll</span><span class="T7"> : Scroll - object for Scroll class</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get scroll details.</p><p>3.Device_Settings_Agent will set scroll details to “Scroll object”.</p><p>4.Device_Settings_Agent will get scroll details.</p><p>5.TM compares the scroll details(iteration and duration) before and after setting the value of iteration and duration.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the scroll value of Text Display before and after setting the value for errors.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setScroll</p><p>TestMgr_DS_managerDeinitialize</p><p> </p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetScroll_Middle_Value_test_50</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro18"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Audio Output Port API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro10"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_51</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the minimum audio level.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p> </p><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setLevel(float)</p><p>AudioOutputPort::getLevel();</p><p>device::Manager::DeInitialize()</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetLevel: float – newLevel</p><p>Eg: value is 0.5</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio level. </p><p>3.Device_Settings_Agent will set audio level to “newLevel”.</p><p>4. Device_Settings_Agent will get audio level.</p><p>5.TM compares the audio level  before and after setting the value of level.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th)</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio level before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setLevel</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetAudioLevel_Minimum_test_51</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro25"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_52</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the maximum audio level.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p> </p><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setLevel(float)</p><p>AudioOutputPort::getLevel();</p><p>device::Manager::DeInitialize()</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetLevel: float – newLevel</p><p>Eg: value is 100.000</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio level. </p><p>3.Device_Settings_Agent will set audio level to “newLevel”.</p><p>4. Device_Settings_Agent will get audio level.</p><p>5.TM compares the audio level  before and after setting the value of level.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio level before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setLevel</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetAudioLevel_Maximum_test_52</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro10"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_53</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the audio level with valid value.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p> </p><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setLevel(float)</p><p>AudioOutputPort::getLevel();</p><p>device::Manager::DeInitialize()</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetLevel: float – newLevel</p><p>Eg: value is 50.00</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio level. </p><p>3.Device_Settings_Agent will set audio level to “newLevel”.</p><p>4. Device_Settings_Agent will get audio level.</p><p>5.TM compares the audio level  before and after setting the value of level.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th)</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio level before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setLevel</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetAudioLevel_value in range_test_53</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro25"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_54</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the audio level with invalid value.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p> </p><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setLevel(float)</p><p>AudioOutputPort::getLevel();</p><p>device::Manager::DeInitialize()</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetLevel: float – newLevel</p><p>Eg: value is -50.00</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio level. </p><p>3.Device_Settings_Agent will set audio level to “newLevel”.</p><p>4. Device_Settings_Agent will get audio level.</p><p>5.TM compares the audio level  before and after setting the value of level.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for error in setting the audio level .</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setLevel</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetAudioLevel_value outof range_test_54</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_55</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –Set the db value as maximum</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setDB(float);</p><p>AudioOutputPort::getDB();</p><p>AudioOutputPort::getMaxDB()</p><p>AudioOutputPort::getMinDB()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetDB: int – newDb</p><p>Eg:7</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio db level used in audio output port. </p><p>3.Device_Settings_Agent will set audio db level used in audio output port to “newDb”. </p><p>4.Device_Settings_Agent will get audio db level used in audio output port. </p><p>5.TM compares the audio level  before and after setting the value of db.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5h)</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio db value before and after setting the value.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setDB</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDB_Maximum_test_55</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro22"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_56</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –Set the db value as minimum</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setDB(float);</p><p>AudioOutputPort::getDB();</p><p>AudioOutputPort::getMaxDB()</p><p>AudioOutputPort::getMinDB()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetDB: int – newDb</p><p>Eg:0</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio db level used in audio output port. </p><p>3.Device_Settings_Agent will set audio db level used in audio output port to “newDb”. </p><p>4.Device_Settings_Agent will get audio db level used in audio output port. </p><p>5.TM compares the audio level  before and after setting the value of db.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">th</span><span class="T9">)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio db value before and after setting the value.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setDB</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDB_Minimum_test_56</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro22"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_57</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –Set the db value as valid.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setDB(float);</p><p>AudioOutputPort::getDB();</p><p>AudioOutputPort::getMaxDB()</p><p>AudioOutputPort::getMinDB()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetDB: int – newDb</p><p>Eg:4</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio db level used in audio output port. </p><p>3.Device_Settings_Agent will set audio db level used in audio output port to “newDb”. </p><p>4.Device_Settings_Agent will get audio db level used in audio output port. </p><p>5.TM compares the audio level  before and after setting the value of db</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">th)</span><span class="T9">.</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio db value before and after setting the value.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setDB</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDB_valid_value_test_57</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro22"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_58</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –Set the db value as negative invalid value</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setDB(float);</p><p>AudioOutputPort::getDB();</p><p>AudioOutputPort::getMaxDB()</p><p>AudioOutputPort::getMinDB()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetDB: int – newDb</p><p>Eg:-20</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio db level used in audio output port. </p><p>3.Device_Settings_Agent will set audio db level used in audio output port to “newDb”. </p><p>4.Device_Settings_Agent will get audio db level used in audio output port. </p><p>5.TM compares the audio level  before and after setting the value of db.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5<span class="T8">h)</span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for error in setting the audio db value.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setDB</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDB_Invalid_Value_test_58</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_59</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  encoding format to AC3</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedEncodings()</p><p>AudioOutputPort::getEncoding()</p><p>AudioOutputPort::setEncoding(int)</p><p>AudioOutputPort::setEncoding(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>setEncoding<span class="T1"> : string</span></p><p><span class="T1">E.g.: AC3</span></p><p><span class="T6">setEncoding</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 1</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported encoding formats.</p><p>3.Device_Settings_Agent will get the current encoding format.</p><p>4.Device_Settings_Agent will set new encoding format.</p><p>5.Device_Settings_Agent will get the current encoding format.</p><p>6.Device_Settings_Agent will check the current encoding format with new encoding format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the encoding format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedEncodings</p><p>TestMgr_DS_AOP_setEncoding</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetEncoding_AC3_FORMAT_test_59</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_60</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  encoding format to PCM.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedEncodings()</p><p>AudioOutputPort::getEncoding()</p><p>AudioOutputPort::setEncoding(int)</p><p>AudioOutputPort::setEncoding(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>setEncoding<span class="T1"> : string</span></p><p><span class="T1">E.g.: PCM</span></p><p><span class="T6">setEncoding</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 2</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported encoding formats.</p><p>3.Device_Settings_Agent will get the current encoding format.</p><p>4.Device_Settings_Agent will set new encoding format.</p><p>5.Device_Settings_Agent will get the current encoding format.</p><p>6.Device_Settings_Agent will check the current encoding format with new encoding format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the encoding format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedEncodings</p><p>TestMgr_DS_AOP_setEncoding</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetEncoding_PCM_FORMAT_test_60</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_61</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  encoding format to DISPLAY</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedEncodings()</p><p>AudioOutputPort::getEncoding()</p><p>AudioOutputPort::setEncoding(int)</p><p>AudioOutputPort::setEncoding(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>setEncoding<span class="T1"> : string</span></p><p><span class="T1">E.g.: DISPLAY</span></p><p><span class="T6">setEncoding</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 3</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported encoding formats.</p><p>3.Device_Settings_Agent will get the current encoding format.</p><p>4.Device_Settings_Agent will set new encoding format.</p><p>5.Device_Settings_Agent will get the current encoding format.</p><p>6.Device_Settings_Agent will check the current encoding format with new encoding format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the encoding format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedEncodings</p><p>TestMgr_DS_AOP_setEncoding</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetEncoding_DISPLAY_FORMAT_test_61</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_62</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  encoding format to NONE.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedEncodings()</p><p>AudioOutputPort::getEncoding()</p><p>AudioOutputPort::setEncoding(int)</p><p>AudioOutputPort::setEncoding(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>setEncoding<span class="T1"> : string</span></p><p><span class="T1">E.g.: NONE</span></p><p><span class="T6">setEncoding</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported encoding formats.</p><p>3.Device_Settings_Agent will get the current encoding format.</p><p>4.Device_Settings_Agent will set new encoding format.</p><p>5.Device_Settings_Agent will get the current encoding format.</p><p>6.Device_Settings_Agent will check the current encoding format with new encoding format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the encoding format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedEncodings</p><p>TestMgr_DS_AOP_setEncoding</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetEncoding_NONE_test_62</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_63</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  encoding format by passing Invalid value.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedEncodings()</p><p>AudioOutputPort::getEncoding()</p><p>AudioOutputPort::setEncoding(int)</p><p>AudioOutputPort::setEncoding(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>setEncoding<span class="T1"> : string</span></p><p><span class="T1">E.g.: INVALID</span></p><p><span class="T6">setEncoding</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 5</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported encoding formats.</p><p>3.Device_Settings_Agent will get the current encoding format.</p><p>4.Device_Settings_Agent will set new encoding format.</p><p>5.Device_Settings_Agent will get the current encoding format.</p><p>6.Device_Settings_Agent will check the current encoding format with new encoding format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the encoding format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedEncodings</p><p>TestMgr_DS_AOP_setEncoding</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetEncoding_Invalid_FORMAT_test_63</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_64</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  compression format to LIGHT</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedCompression()</p><p>AudioOutputPort::getCompression()</p><p>AudioOutputPort::setCompression(int)</p><p>AudioOutputPort::setCompression(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>SetCompression<span class="T1"> : string</span></p><p><span class="T1">E.g.: LIGHT</span></p><p><span class="T6">SetCompression</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 1.</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported compression formats.</p><p>3.Device_Settings_Agent will get the current compression format.</p><p>4.Device_Settings_Agent will set new compression format.</p><p>5.Device_Settings_Agent will get the current compression format.</p><p>6.Device_Settings_Agent will check the current compression format with new compression format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the compression format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedCompressions</p><p>TestMgr_DS_AOP_setCompression</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetCompression_LIGHT_FORMAT_64</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_65</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  compression format to MEDIUM</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedCompression()</p><p>AudioOutputPort::getCompression()</p><p>AudioOutputPort::setCompression(int)</p><p>AudioOutputPort::setCompression(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>SetCompression<span class="T1"> : string</span></p><p><span class="T1">E.g.: MEDIUM</span></p><p><span class="T6">SetCompression</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 2</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported compression formats.</p><p>3.Device_Settings_Agent will get the current compression format.</p><p>4.Device_Settings_Agent will set new compression format.</p><p>5.Device_Settings_Agent will get the current compression format.</p><p>6.Device_Settings_Agent will check the current compression format with new compression format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the compression format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedCompressions</p><p>TestMgr_DS_AOP_setCompression</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetCompression_MEDIUM_FORMAT_65</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_66</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  compression format to HEAVY</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedCompression()</p><p>AudioOutputPort::getCompression()</p><p>AudioOutputPort::setCompression(int)</p><p>AudioOutputPort::setCompression(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>SetCompression<span class="T1"> : string</span></p><p><span class="T1">E.g.: MEDIUM</span></p><p><span class="T6">SetCompression</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 3</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported compression formats.</p><p>3.Device_Settings_Agent will get the current compression format.</p><p>4.Device_Settings_Agent will set new compression format.</p><p>5.Device_Settings_Agent will get the current compression format.</p><p>6.Device_Settings_Agent will check the current compression format with new compression format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the compression format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedCompressions</p><p>TestMgr_DS_AOP_setCompression</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetCompression_HEAVY_FORMAT_66</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_67</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  compression format to NONE</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedCompression()</p><p>AudioOutputPort::getCompression()</p><p>AudioOutputPort::setCompression(int)</p><p>AudioOutputPort::setCompression(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>SetCompression<span class="T1"> : string</span></p><p><span class="T1">E.g.: MEDIUM</span></p><p><span class="T6">SetCompression</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported compression formats.</p><p>3.Device_Settings_Agent will get the current compression format.</p><p>4.Device_Settings_Agent will set new compression format.</p><p>5.Device_Settings_Agent will get the current compression format.</p><p>6.Device_Settings_Agent will check the current compression format with new compression format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the compression format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedCompressions</p><p>TestMgr_DS_AOP_setCompression</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetCompression_NONE_67</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_68</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  compression format to INVALID</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedCompression()</p><p>AudioOutputPort::getCompression()</p><p>AudioOutputPort::setCompression(int)</p><p>AudioOutputPort::setCompression(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>SetCompression<span class="T1"> : string</span></p><p><span class="T1">E.g.: INVALID</span></p><p><span class="T6">SetCompression</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 5</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported compression formats.</p><p>3.Device_Settings_Agent will get the current compression format.</p><p>4.Device_Settings_Agent will set new compression format.</p><p>5.Device_Settings_Agent will get the current compression format.</p><p>6.Device_Settings_Agent will check the current compression format with new compression format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the compression format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedCompressions</p><p>TestMgr_DS_AOP_setCompression</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetCompression_INVALID_FORMAT_68</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_69</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set stereo format to MONO</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(int)</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: MONO</span></p><p><span class="T6">setStereoMode</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 1</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetStereoMode_MONO_FORMAT_69</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_70</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set stereo format to STEREO</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(int)</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: STEREO</span></p><p><span class="T6">setStereoMode</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 2</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetStereoMode_STEREO_FORMAT_70</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_71</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set stereo format to SURROUND</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(int)</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: SURROUND</span></p><p><span class="T6">setStereoMode</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 3</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetStereoMode_SURROUND_FORMAT_71</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_72</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set stereo format to UNKNOWN</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(int)</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: UNKNOWN</span></p><p><span class="T6">setStereoMode</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetStereoMode_UNKNOWN_72</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_73</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set stereo format by passing invalid value.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(int)</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: INVALID</span></p><p><span class="T6">setStereoMode</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 5</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(5th). </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetStereoMode_INVALID_FORMAT_73</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro18"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Video Device API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_74</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display video device mode for the video device with None zoom.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setDFC : int -Id- 0</p><p>setDFC : String -</p><p>E.g.: None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDFC_None_ZOOM_test_74</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_75</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display video device mode for the video device with full zoom</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setDFC : int -Id- 1</p><p>setDFC : String -</p><p>E.g.: full</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDFC_FULL_ZOOM_test_75</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_76</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting –  Get and Set the display video device mode for the video device with platform zoom</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setDFC : int -Id- 2</p><p>setDFC : String -</p><p>E.g.: platform</p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetDFC_PLATFORM_ZOOM_test_76</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>RDKTT-544 it is interface change</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_77</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting –  Get and Set the display video device mode for the video device with CCO zoom</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setDFC : int -Id- 2</p><p>setDFC : String -</p><p>E.g.: CCO</p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetDFC_CCO_ZOOM_test_77</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>RDKTT-544 it is interface change</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_78</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting –  Get and Set the display video device mode for the video device with PanScan zoom</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setDFC : int -Id- 2</p><p>setDFC : String -</p><p>E.g.: PanScan</p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetDFC_PanScan_ZOOM_test_78</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>RDKTT-544 it is interface change</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_79</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting –  Get and Set the display video device mode for the video device with”Zoom 16x9” zoom</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setDFC : int -Id- 2</p><p>setDFC : String -</p><p>E.g.: Zoom 16x9</p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetDFC_Zoom16x9_test_79</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>RDKTT-544 it is interface change</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_80</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting –  Get and Set the display video device mode for the video device with Pillarbox 4x3 zoom</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setDFC : int -Id- 2</p><p>setDFC : String -</p><p>E.g.: Pillarbox 4x3</p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetDFC_Pillarbox4x3_ZOOM_test_80</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>RDKTT-544 it is interface change</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_81</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display video device mode for the video device with invalid zoom</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setDFC : int -Id- 2</p><p>setDFC : String -</p><p>E.g.: INVALID</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5. Device_Settings_Agent will check for the new display settings and will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDFC_INVALID_ZOOM_test_81</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro18"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Video Output Port API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_82</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 480i</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 480i.</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_480i_test_82</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_83</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 720p</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 720p</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_720p_test_83</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_84</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 1080i</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 1080i</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_1080i_test_84</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_85</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 480p</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 480p</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_480p_test_85</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_86</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 576p50</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 576p50</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_576p50_test_86</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_87</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 720p50</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 720p50</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result..</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_720p50_test_87</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_88</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 1080p24.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 1080p24.</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_1080p24_test_88</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_89</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 1080p.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 1080p.</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_1080p_test_89</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_90</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 1080i50</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 1080i50</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_1080i50_test_90</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_91</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 1080p30</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 1080p30</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_1080p30_test_91</p></td><td style="text-align:left;width:64.2pt; " class="ce3"><p>DS_Resolution_1080p30_test_91</p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_92</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 1080p60</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 1080p60</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_1080p60_test_92</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_93</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with 1080i for an invalid port name.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 1080i</p><p>GetVideoOutputPort: string -</p><p>E.g: HDMI8</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_Invalid_port_test_93</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_94</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display Resolution setting with invalid value for valid port name.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 820p</p><p>GetVideoOutputPort: string -</p><p>E.g: HDMI0</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_Invalid_value_test_94</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro18"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Host API</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_95</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – set and get the power mode as ON</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::setPowerMode(int)</p><p>Host::getPowerMode()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setPowerMode : int </p><p>E.g.: 0</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will add listener for power mode change.</p><p>3.Device_Settings_Agent will check for the power state of STB.</p><p>4.Device_Settings_Agent will set the desired power state of STB.</p><p>5.Device_Settings_Agent will remove listener for power mode change.</p><p>6.Device_Settings_Agent will set the desired power state of STB.</p><p>7.Device_Settings_Agent will check for the state of STB and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the power state of STB before and after setting it.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the log message before and after removing power mode change Listener.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_addPowerModeListener</p><p>TestMgr_DS_HOST_setPowerMode</p><p>TestMgr_DS_HOST_removePowerModeListener</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetPowerMode_ON_test_95</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>Power Mode API is invalid in future releases</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_96</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – set and get the power mode as OFF</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::setPowerMode(int)</p><p>Host::getPowerMode()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setPowerMode : int </p><p>E.g.: 1</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will add listener for power mode change.</p><p>3.Device_Settings_Agent will check for the power state of STB.</p><p>4.Device_Settings_Agent will set the desired power state of STB.</p><p>5.Device_Settings_Agent will remove listener for power mode change.</p><p>6.Device_Settings_Agent will set the desired power state of STB.</p><p>7.Device_Settings_Agent will check for the state of STB and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the power state of STB before and after setting it.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the log message before and after removing power mode change Listener.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_addPowerModeListener</p><p>TestMgr_DS_HOST_setPowerMode</p><p>TestMgr_DS_HOST_removePowerModeListener</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetPowerMode_OFF_test_96</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>time format not supported</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_97</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – set and get the power mode as STANDBY</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Boundary condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::setPowerMode(int)</p><p>Host::getPowerMode()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setPowerMode : int </p><p>E.g.: 2</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will add listener for power mode change.</p><p>3.Device_Settings_Agent will check for the power state of STB.</p><p>4.Device_Settings_Agent will set the desired power state of STB.</p><p>5.Device_Settings_Agent will remove listener for power mode change.</p><p>6.Device_Settings_Agent will set the desired power state of STB.</p><p>7.Device_Settings_Agent will check for the state of STB and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the power state of STB before and after setting it.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the log message before and after removing power mode change Listener.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_addPowerModeListener</p><p>TestMgr_DS_HOST_setPowerMode</p><p>TestMgr_DS_HOST_removePowerModeListener</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetPowerMode_STANDBY_test_97</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>Power Mode API is invalid in future releases</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_98</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – set and get the power mode as Invalid value</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Negative(Boundary Condition)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::setPowerMode(int)</p><p>Host::getPowerMode()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setPowerMode : int </p><p>E.g.: 5</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will add listener for power mode change.</p><p>3.Device_Settings_Agent will check for the power state of STB.</p><p>4.Device_Settings_Agent will set the desired power state of STB.</p><p>5.Device_Settings_Agent will remove listener for power mode change.</p><p>6.Device_Settings_Agent will set the desired power state of STB.</p><p>7.Device_Settings_Agent will check for the state of STB and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check for the error in setting the power state of STB</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_addPowerModeListener</p><p>TestMgr_DS_HOST_setPowerMode</p><p>TestMgr_DS_HOST_removePowerModeListener</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetPowerMode_Invalid_test_98</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>Power Mode API is invalid in future releases</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro18"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Stress Test</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro26"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS_99</p></td><td style="text-align:left;width:128.44pt; " class="ce4"><p>Device Setting – set and get the power mode as ON and OFF continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce4"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce4"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce4"><p>device::Manager::Initialize()</p><p>Host::setPowerMode(int)</p><p>Host::getPowerMode()</p><p>Host::addPowerModeListener()</p><p>Host::removePowerModeListener()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce4"><p>setPowerMode : int </p><p>E.g.: 0 or 1</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce4"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will add listener for power mode change.</p><p>3.Device_Settings_Agent will check for the power state of STB.</p><p>4.Device_Settings_Agent will set the desired power state of STB.</p><p>5.Device_Settings_Agent will remove listener for power mode change.</p><p>6.Device_Settings_Agent will set the desired power state of STB.</p><p>7.Device_Settings_Agent will wait for 100 ms and change to another power state and verify the change.</p><p>8. The steps 4-7 will be repeated for 100 times and check the successful change of power and store the result.</p><p>9.Device_Settings_Agent will check for the state of STB and will return SUCCESS or FAILURE based on the result. </p></td><td style="text-align:left;width:99.89pt; " class="ce28"><p>Checkpoint 1.<span class="T1"> Check the power state of STB before and after setting it for all iterations</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the log message before and after removing power mode change Listener.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce4"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_addPowerModeListener</p><p>TestMgr_DS_HOST_setPowerMode</p><p>TestMgr_DS_HOST_removePowerModeListener</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce4"><p>DS_SetPowerMode_STRESS_test_99</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>Set Power Mode API is invalid in future releases</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro27"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_100</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set brightness for front panel Indicator with random values within range continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelIndicator::getInstance()</p><p>FrontPanelIndicator::getIndicators()</p><p>FrontPanelIndicator::getIndicator(string)</p><p>FrontPanelIndicator::getBrightness() </p><p>FrontPanelIndicator::setBrightness(int)                  device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string  - name</span></p><p><span class="T1">E.g.: POWER</span></p><p><span class="T6">SetBrightness</span><span class="T7"> : int - brightness </span></p><p><span class="T1">E.g.: Value  0. </span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of Indicators.</p><p>3.Device_Settings_Agent will get the indicators by passing the LED indicators.</p><p>4.Device_Settings_Agent will get the value of brightness for LED Indicator.</p><p>5.Device_Settings_Agent will set the brightness value to “brightness” for the LED Indicator.</p><p>6.Device_Settings_Agent will check for the new brightness value.</p><p>7.Device_Settings_Agent will wait for 100 ms and change to another brightness value and verify the change.</p><p>8. The steps 4-7 will be repeated for 100 times and check the successful change of resolution and store the result.</p><p>9.Device_Settings_Agent will return SUCCESS or FAILURE based on the result.</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the value of POWER Indicator brightness after and before setting the value of brightness.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_getIndicators</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBrightness_STRESS_test_100</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro26"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_101</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the color of the POWER LED with supported  colors continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getColors() </p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::getColor()</p><p>FrontPanelConfig::setColor(int)      </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name</span></p><p><span class="T1">E.g.: name : “POWER”</span></p><p><span class="T6">SetColor</span><span class="T7"> : int – color</span></p><p><span class="T1">E.g.: 0</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of colors.</p><p>3.Device_Settings_Agent will get a indicator by passing”name:POWER”.</p><p>4.Device_Settings_Agent will get the color for POWER Indicator.</p><p>5.Device_Settings_Agent will set the new color to “color” for the POWER Indicator.</p><p>6.Device_Settings_Agent will check for the new color.</p><p>7.Device_Settings_Agent will wait for 100 ms and change to another color and verify the change.</p><p>8. The steps 4-7 will be repeated for 100 times and check the successful change of color and store the result.</p><p>9.Device_Settings_Agent will return SUCCESS or FAILURE based on the result</p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p><span class="T6">Checkpoint 1</span><span class="T7">.Check for the color of POWER Indicator after and before setting the color.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_FP_getSupportedColors</p><p>TestMgr_DS_FP_setColor</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetColor_STRESS_test_101</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro6"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_102</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the blink value of the POWER LED with different values continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getIndicator(string)</p><p>FrontPanelConfig::setBlink(int)</p><p>FrontPanelConfig::getBlink()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getIndicator<span class="T1"> : string – name </span></p><p><span class="T1">Eg:name: “POWER”</span></p><p><span class="T6">setBlink</span><span class="T7"> : int – blink</span></p><p><span class="T1">E.g.: 1,2</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get Blink interval of front panel indicator LED.</p><p>3.Device_Settings_Agent will set Blink interval to “blink ” of front panel indicator LED.</p><p>4.Device_Settings_Agent will get  Blink interval of front panel indicator LED.</p><p>5.TM compares the Blink Interval before and after setting the Interval. </p><p>6.Device_Settings_Agent will wait for 100 ms and change to another blink rate and verify the change.</p><p>7. The steps 4-7 will be repeated for 100 times and check the successful change of blink rate and store the result.</p><p>8.Device_Settings_Agent will return SUCCESS or FAILURE based on the result</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the blink value of POWER Indicator after and before setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setBlink</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetBlink_STRESS_test_102</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro28"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_103</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the Time format with different values continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce11"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getCurrentTimeForamt() </p><p>FrontPanelConfig::setTimeFormat(int)</p><p>FrontPanelConfig::setTime()</p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p> </p><p>setTimeFormat<span class="T1"> : int id </span></p><p><span class="T1">E.g.: id: 0.</span></p><p><span class="T1">SetTime : int – hrs, int – mins</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the Time format displayed in the front panel </p><p>3.Device_Settings_Agent will get Time format in the front panel.</p><p>4.Device_Settings_Agent will set a new time by passing “hrs” and “mins” value.</p><p>5.TM makes RPC calls for getting the Time format from Device_Settings_Agent.</p><p>7.Device_Settings_Agent will wait for 100 ms and change to another time format and verify the change.</p><p>8. The steps 3-7 will be repeated for 100 times and check the successful change of time and store the result.</p><p>9.Device_Settings_Agent will return SUCCESS or FAILURE based on the result</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the Time format in the Front panel after and before setting the format.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check for the return value of setTime </span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p> </p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetTime_FORMAT_STRESS_test_103</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro26"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_104</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the Text display with different strings continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce11"><p>device::Manager::Initialize()   </p><p>FrontPanelConfig::getInstance()</p><p><span class="T1">FrontPanelConfig::getTextDisplays ()      </span></p><p><span class="T2">FrontPanelConfig::getTextDisplay(string)</span></p><p><span class="T2">FrontPanelConfig::setText()</span></p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getTextDisplay<span class="T1"> : string – name </span></p><p><span class="T1">name:“TEXT” </span></p><p><span class="T1">SetText : string- text</span></p><p><span class="T1">E.g.: text: “any word”</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the list of test display panel in the front Panel.</p><p>3.Device_Settings_Agent will get a instance for single test display panel by “passing name:TEXT”</p><p>4.Device_Settings_Agent will set some text in the text display panel of front panel indicator.</p><p>5.TM makes RPC calls for getting the TEXT format from Device_Settings_Agent.</p><p>6.Device_Settings_Agent will wait for 100 ms and change to another TEXT and verify the change.</p><p>7. The steps 4-6 will be repeated for 100 times and check the successful change of  new Text and store the result.</p><p>8.Device_Settings_Agent will return SUCCESS or FAILURE based on the result</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p> </p><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check for the return value of setText APIs.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setText</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_FP_setTimeForamt</p><p>TestMgr_DS_FP_getTextDisplays</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetText_STRESS_test_104</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro15"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_105</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the  information for scroll with random values for Viteration,Hiteration &amp; hold_duration,  continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                 FrontPanelConfig::getInstance()</p><p>FrontPanelConfig::getTextDisplay(String)</p><p>FrontPanelConfig::getScroll();</p><p>FrontPanelConfig::setScroll(Scroll);</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>getTextDisplay<span class="T1"> : string  “TEXT”  </span></p><p><span class="T6">SetScroll</span><span class="T7"> : Scroll - object for Scroll class</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get scroll details.</p><p>3.Device_Settings_Agent will set scroll details to “Scroll object”.</p><p>4.Device_Settings_Agent will get scroll details.</p><p>5.Device_Settings_Agent will wait for 100 ms and change to another TEXT and verify the change.</p><p>6. The steps 3-5 will be repeated for 100 times and check the successful change of  new Text and store the result.</p><p>7.TM compares the scroll details(iteration and duration) before and after setting the value of iteration and duration.</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the scroll value of Text Display before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setScroll</p><p>TestMgr_DS_managerDeinitialize</p><p> </p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetScroll_STRESS_test_105</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro13"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_106</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting – Get and Set the random  audio level continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p> </p><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setLevel(float)</p><p>AudioOutputPort::getLevel();</p><p>device::Manager::DeInitialize()</p><p> </p><p> </p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetLevel: float – newLevel</p><p>Eg: value is 100.000</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio level. </p><p>3.Device_Settings_Agent will set audio level to “newLevel”.</p><p>4. Device_Settings_Agent will get audio level.</p><p>5.Device_Settings_Agent will wait for 100 ms and change to another audio level and verify the change.</p><p>6. The steps 3-5 will be repeated for 100 times and check the successful change of  audio level and store the result.</p><p>7.TM compares the audio level  before and after setting the value of level.</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio level before and after setting the value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setLevel</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetAudioLevel_STRESS_test_106</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro26"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_107</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –Set the db with random values continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::setDB(float);</p><p>AudioOutputPort::getDB();</p><p>AudioOutputPort::getMaxDB()</p><p>AudioOutputPort::getMinDB()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p> </p><p>SetDB: int – newDb</p><p>Eg:</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get audio db level used in audio output port. </p><p>3.Device_Settings_Agent will set audio db level used in audio output port to “newDb”. </p><p>4.Device_Settings_Agent will get audio db level used in audio output port.</p><p>5.Device_Settings_Agent will check the current encoding format with new encoding format set.</p><p>6.Device_Settings_Agent will wait for 100 ms and change to another db level value and verify the change.</p><p>7.The steps 3-6 will be repeated for 100 times and check the successful change of db level and store the result. </p><p>5.TM compares the audio level  before and after setting the value of db.</p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7">Check for the value of audio db value before and after setting the value.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_setDB</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDb_STRESS_test_107</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro29"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_108</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set the supporting encoding format continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedEncodings()</p><p>AudioOutputPort::getEncoding()</p><p>AudioOutputPort::setEncoding(int)</p><p>AudioOutputPort::setEncoding(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>setEncoding<span class="T1"> : string</span></p><p><span class="T1">E.g.: AC3</span></p><p><span class="T6">setEncoding</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 1</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported encoding formats.</p><p>3.Device_Settings_Agent will get the current encoding format.</p><p>4.Device_Settings_Agent will set new encoding format.</p><p>5.Device_Settings_Agent will get the current encoding format.</p><p>6.Device_Settings_Agent will check the current encoding format with new encoding format set.</p><p>7.Device_Settings_Agent will wait for 100 ms and change to another encoding format and verify the change.</p><p>8.The steps 3-7 will be repeated for 100 times and check the successful change of encoding format and store the result.</p><p>9.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(8<span class="T8">th</span><span class="T9">).</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the encoding format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedEncodings</p><p>TestMgr_DS_AOP_setEncoding</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetEncoding_STRESS_test_108</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro30"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_109</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set  the supported compression format continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedCompression()</p><p>AudioOutputPort::getCompression()</p><p>AudioOutputPort::setCompression(int)</p><p>AudioOutputPort::setCompression(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce26"><p>SetCompression<span class="T1"> : string</span></p><p><span class="T1">E.g.: LIGHT</span></p><p><span class="T6">SetCompression</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 1.</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported compression formats.</p><p>3.Device_Settings_Agent will get the current compression format.</p><p>4.Device_Settings_Agent will set new compression format.</p><p>5.Device_Settings_Agent will get the current compression format.</p><p>6.Device_Settings_Agent will check the current compression format with new compression format set.</p><p>7.Device_Settings_Agent will wait for 100 ms and change to another compression format  and verify the change.</p><p>8.The steps 3-7 will be repeated for 100 times and check the successful change of compression format and store the result.</p><p>9.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(8<span class="T8">th</span><span class="T9">). </span></p></td><td style="text-align:left;width:99.89pt; " class="ce3"><p> </p><p><span class="T6">Checkpoint 1.</span><span class="T7"> Check the compression format before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedCompressions</p><p>TestMgr_DS_AOP_setCompression</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetCompression_STRESS_test_109</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro31"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_110</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and set the supported stereo format continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(int)</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: MONO</span></p><p><span class="T6">setStereoMode</span><span class="T7"> : int – id</span></p><p><span class="T1">E.g.: 1</span></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set.</p><p>7.Device_Settings_Agent will wait for 100 ms and change to another stereo format and verify the change.</p><p>8.The steps 3-7 will be repeated for 100 times and check the successful change of stereo format and store the result.</p><p>9.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(8<span class="T8">th</span><span class="T9">).</span></p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetStereoMode_STRESS_test_110</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro19"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_111</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the display video device mode for the video device with different zoom values continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoDevices()</p><p>VideoDevice::SetPlatformDFC()</p><p>VideoDevice::setDFC(int) or VideoDevice::setDFC(string)</p><p>VideoDevice::getDFC()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setDFC : int -Id- 0</p><p>setDFC : String -</p><p>E.g.: None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display mode settings to platform settings.(new Zoom settings).</p><p>3.Device_Settings_Agent will get the display mode settings.</p><p>4. Device_Settings_Agent will set the new display mode settings(new Zoom settings).</p><p>5.Device_Settings_Agent will wait for 100 ms and change to another zoom value and verify the change.</p><p>6.The steps 3-5 will be repeated for 100 times and check the successful change of zooming and store the result.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result.</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the Zoom Setting is set for platform.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the Zoom settings before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VD_setDFC</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetDFC_STRESS_test_111</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro32"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS_112</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Get and Set the supported display Resolution continuously for every 100ms repeatedly for x times.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>AudioOutputPort::getSupportedResolutions()</p><p>VideoOutputPort::getDfeaultResolution()</p><p>VideoOutputPort::setResolution(string)</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getResolution()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>setResolution: string -</p><p>E.g.: 480i.</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.display device should be connected.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list resolution supported by a given port.</p><p>3.Device_Settings_Agent will get the default resolution supported by a given port.</p><p>4.Device_Settings_Agent will get the status of display connection.</p><p>5.Device_Settings_Agent will get the display resolution.</p><p>6. Device_Settings_Agent will set the new display resolution.</p><p>7. Device_Settings_Agent will check for the new display resolution </p><p>8.Device_Settings_Agent will wait for 100 ms and change to another resolution and verify the change.</p><p>9. The steps 5-8 will be repeated for 100 times and check the successful change of resolution and store the result.</p><p>10.Device_Settings_Agent will return SUCCESS or FAILURE based on the result. </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1.<span class="T1"> Check the display connection status with “Connected” status.</span></p><p><span class="T1"/></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the display Resolution value before and after setting it.</span></p><p><span class="T6">Checkpoint 3.</span><span class="T7"> Check for the presence of the defaultResoultion and current resolution in the list of supported resolutions.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_Resolutions</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_Resolution_STRESS_test_112</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro18"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>Reboot Test</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro24"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS113</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Listing display details before and after rebooting the device</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::getDisplay()</p><p>VideoOutputPort::isDisplayConnected()</p><p>VideoOutputPort::getManufacturerWeek()</p><p>VideoOutputPort::getManufacturerYear()</p><p>VideoOutputPort::getProductCode()</p><p>VideoOutputPort::getSerialNumber()</p><p>device::Manager::DeInitialize()</p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3.Agent executable should be up and from startup.</p></td><td style="text-align:left;width:175.21pt; " class="ce31"><p>1.TM loads the Device_Settings_Agent via the test agent </p><p>2.Device_Settings_Agent will list the details about videoOutputPort before rebooting the box.</p><p>3.TM issues command to reboot the device.</p><p>4.Device_Settings_Agent will list the details about VOP after rebooting the box.</p><p>5.TM will get the two list and compare both are same.</p><p>6.Depends on result of above 5<span class="T8">th</span><span class="T9"> step TM will return success or failure.</span></p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1<span class="T1"> Check for return value of the APIs.</span></p><p><span class="T6">Checkpoint 2</span><span class="T7"> Check for the list before and after the reboot.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_isDisplayConnected</p><p>TestMgr_DS_VOP_getDisplayDetails</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_GetDisplayDetails_Reboot_test_113</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro13"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS114</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  Checking the current Aspect Ratio  with available Aspect Ratio formats before and after rebooting device.</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>VideoOutputPort::Display::getAspectRatio()</p><p>VideoOutputPort::isDisplayConnected()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>null</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will get the current Aspect Ratio.</p><p>3.Device_Settings_Agent will check for the current aspect Ratio with the list of available aspect Ratio formats.</p><p>4.TM issues command to reboot the device.</p><p>5.Device_Settings_Agent will check for the current aspect Ratio with the list of available aspect Ratio formats after rebooting the box.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step(3rd). </p><p> </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current aspect Ratio present in the list of available aspect Ratio formats before and after rebooting the device.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_isDisplayConnected</p><p>TestMgr_DS_VOP_getAspectRatio</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_GetAspect_Ratio_Reboot_test_114</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro12"><td colspan="13" style="text-align:left;width:122.91pt; " class="ce2"><p>JIRA Ticket mapped</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td></tr><tr class="ro33"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS115</p></td><td style="text-align:left;width:128.44pt; " class="ce12"><p>Check too frequent calls (50 times) to FP setState</p></td><td style="text-align:left;width:44.39pt; " class="ce12"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce17"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce12"><p>device::Manager::Initialize() </p><p>device::FrontPanelIndicator::setState</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce12"><p>integer state(0,1)</p><p>string indicator_name ("Power")</p></td><td style="text-align:left;width:127.64pt; " class="ce13"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce12"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will set the state of front panel to ON/OFF for 50 times.</p><p>3. Device_Settings_Agent will check for the state after each set will return SUCCESS or FAILURE</p></td><td style="text-align:left;width:99.89pt; " class="ce19"><p>Checkpoint 1 Check for return value of the state in each loop</p></td><td style="text-align:left;width:58.65pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce12"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setState</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce33"><p>DS_SetState_Stress_115</p></td><td style="text-align:left;width:64.2pt; " class="ce37"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/MOT7425-6090">MOT7425-6090 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro10"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS116</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>To check that Front Panel power brightness value is persisted after STB reboot</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce17"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>FrontPanelIndicator::getInstance()</p><p>FrontPanelIndicator::getIndicator(string)</p><p>FrontPanelIndicator::setBrightness(int) </p><p>FrontPanelIndicator::getBrightness() </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>integer brightness=5</p><p>string indicator_name ("Power")</p><p>integer get_only (0,1)</p></td><td style="text-align:left;width:127.64pt; " class="ce13"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1.TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the instance of indicators by passing the “name: POWER”</p><p>3.Device_Settings_Agent will set the brightness value to “brightness” for the POWER Indicator.</p><p>4. Reboot the STB</p><p>5.TM makes RPC calls for getting the POWER Indicator brightness value from Device_Settings_Agent and verify whether the brightness has changed.</p></td><td style="text-align:left;width:99.89pt; " class="ce19"><p>Checkpoint 1 Check for return value of the brightness before and after reboot</p></td><td style="text-align:left;width:58.65pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_Brightness_Persistent_116</p></td><td style="text-align:left;width:64.2pt; " class="ce37"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/XONE-11452">XONE-11452 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro34"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS117</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>To check that Front Panel timer brightness value is persisted after STB reboot</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce17"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>FrontPanelIndicator::getInstance()</p><p>FrontPanelIndicator::getTextDisplay()</p><p>FrontPanelIndicator::setBrightness(int) </p><p>FrontPanelIndicator::getBrightness() </p><p>device::Manager::DeInitialize()</p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>integer brightness=5</p><p>string text="Hello"</p><p>integer get_only (0,1)</p></td><td style="text-align:left;width:127.64pt; " class="ce13"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1.TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the textdisplay by passing the message: "Hello"</p><p>3.Device_Settings_Agent will set the value of brightness for text.</p><p>4.Reboot the STB</p><p>5.TM makes RPC calls for getting the text brightness value from Device_Settings_Agent and verify whether the brightness has changed.</p></td><td style="text-align:left;width:99.89pt; " class="ce19"><p>Checkpoint 1 Check for return value of the brightness before and after reboot</p></td><td style="text-align:left;width:58.65pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_TextBrightness_Persistent_117</p></td><td style="text-align:left;width:64.2pt; " class="ce37"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/XONE-11452">XONE-11452 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS118</p></td><td style="text-align:left;width:128.44pt; " class="ce12"><p>Check resolution value change after STB reboot</p></td><td style="text-align:left;width:44.39pt; " class="ce12"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce17"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce12"><p>device::Manager::Initialize() </p><p>device::VideoOutputPort::setResolution</p><p>device::VideoOutputPort::getResolution</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce12"><p>string resolution="1080i"</p><p>string port_name="HDMI0"</p><p>integer get_only (0,1)</p></td><td style="text-align:left;width:127.64pt; " class="ce13"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce12"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will set the new display resolution.</p><p>3. Reboot the STB</p><p>4. Device_Settings_Agent will check for the display resolution and will return SUCCESS or FAILURE based on the value set in step 2</p></td><td style="text-align:left;width:99.89pt; " class="ce19"><p>Checkpoint 1 Check for return value of the resolution before and after reboot</p></td><td style="text-align:left;width:58.65pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce12"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce12"><p>DS_Resolution_Persistent_118</p></td><td style="text-align:left;width:64.2pt; " class="ce37"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/DELIA-4993">DELIA-4993 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS119</p></td><td style="text-align:left;width:128.44pt; " class="ce14"><p>Check multiple (50 times) toggles between STB Standby and Power-on</p></td><td style="text-align:left;width:44.39pt; " class="ce14"><p>Positive(Stress)</p></td><td style="text-align:left;width:75.29pt; " class="ce21"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce14"><p>device::Manager::Initialize() </p><p>device::Host::setPowerMode</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce14"><p>integer new_power_state (1,2)</p></td><td style="text-align:left;width:127.64pt; " class="ce16"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce14"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will set the power state to ON/Standby for 50 times.</p><p>3. Device_Settings_Agent will check for the power mode after each set will return SUCCESS or FAILURE</p></td><td style="text-align:left;width:99.89pt; " class="ce14"><p>Checkpoint 1 Check for return value of the power mode in each loop</p></td><td style="text-align:left;width:58.65pt; " class="ce34"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce14"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_setPowerMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce14"><p>DS_PowerModeToggle_Stress_119</p></td><td style="text-align:left;width:64.2pt; " class="ce38"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/XITHREE-4867">XITHREE-4867 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M21</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS120</p></td><td style="text-align:left;width:128.44pt; " class="ce12"><p>Check resolution value change after HDMI port disable/enable</p></td><td style="text-align:left;width:44.39pt; " class="ce12"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce17"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce12"><p>device::Manager::Initialize() </p><p>device::VideoOutputPort::setResolution</p><p>device::VideoOutputPort::getResolution</p><p>device::VideoOutputPort::enable</p><p>device::VideoOutputPort::disable</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce12"><p>string resolution="1080i"</p><p>string port_name="HDMI0"</p><p>integer get_only (0,1)</p><p>integer enable(0,1)</p></td><td style="text-align:left;width:127.64pt; " class="ce13"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce12"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will set the new display resolution.</p><p>3. Device_Settings_Agent will set the video output port to disable and then enable </p><p>4. Device_Settings_Agent will check for the display resolution and will return SUCCESS or FAILURE based on the value set in step 2</p></td><td style="text-align:left;width:99.89pt; " class="ce19"><p>Checkpoint 1 Check for return value of the resolution before and after HDMI port disable/enable</p></td><td style="text-align:left;width:58.65pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce12"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_VOP_setEnable</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce12"><p>DS_Resolution_PortStateChange_120</p></td><td style="text-align:left;width:64.2pt; " class="ce37"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/XONE-15300">XONE-15300 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS121</p></td><td style="text-align:left;width:128.44pt; " class="ce12"><p>Check resolution value after power toggling the TV</p></td><td style="text-align:left;width:44.39pt; " class="ce12"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce17"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce12"><p>device::Manager::Initialize() </p><p>device::VideoOutputPort::setResolution</p><p>device::VideoOutputPort::getResolution</p><p>device::Host::setPowerMode</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce12"><p>string resolution="1080i"</p><p>string port_name="HDMI0"</p><p>integer get_only (0,1)</p><p>integer new_power_state (1,3)</p></td><td style="text-align:left;width:127.64pt; " class="ce13"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce12"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will set the new display resolution.</p><p>3. Device_Settings_Agent will set the power mode of STB to OFF and then ON</p><p>4. Device_Settings_Agent will check for the display resolution and will return SUCCESS or FAILURE based on the value set in step 2</p></td><td style="text-align:left;width:99.89pt; " class="ce19"><p>Checkpoint 1 Check for return value of the resolution after setting power mode to standby / on .</p></td><td style="text-align:left;width:58.65pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce12"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_DS_HOST_setPowerMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce12"><p>DS_Resolution_PowerModeChange_121</p></td><td style="text-align:left;width:64.2pt; " class="ce37"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/SAM150-2438"> SAM150-2438 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro34"><td style="text-align:left;width:122.91pt; " class="ce6"><p>CT_DS122</p></td><td style="text-align:left;width:128.44pt; " class="ce12"><p>Change output resolution to 720P before  dvr playback</p></td><td style="text-align:left;width:44.39pt; " class="ce12"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce17"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce12"><p>device::Manager::Initialize() </p><p>device::VideoOutputPort::setResolution</p><p>device::VideoOutputPort::getResolution</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce29"><p><a href="http://ipaddress:8080/vldms/tuner?ocap_locator=ocap://ID">string resolution="720p"
string port_name="HDMI0"
integer get_only (0,1)
string playUrl='http://ipaddress:8080/vldms/tuner?ocap_locator=ocap://ID'</a></p></td><td style="text-align:left;width:127.64pt; " class="ce13"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce12"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the new display resolution.</p><p>3.TDKIntegrationStub Agent will play the live Url after changing the resolution and return SUCCESS or FAILURE based on the result.</p></td><td style="text-align:left;width:99.89pt; " class="ce12"><p>Checkpoint 1. Check the display Resolution value before and after setting it.</p><p>Checkpoint 2. Check if the live trickplay is successful.</p></td><td style="text-align:left;width:58.65pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce12"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_LinearTv_Dvr_Play</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce12"><p>DS_ResolutionChange_VideoPlay_122</p></td><td style="text-align:left;width:64.2pt; " class="ce37"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/PARKER-5605">PARKER-5605 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce3"><p>Script Not Available</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS123</p></td><td style="text-align:left;width:128.44pt; " class="ce15"><p>Verify that EDID value is not retrieved when HDMI is plugged out. Verify that EDID value is retrieved even when HDMI port is connected and disabled.</p></td><td style="text-align:left;width:44.39pt; " class="ce19"><p>Negative</p></td><td style="text-align:left;width:75.29pt; " class="ce22"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce19"><p>device::Manager::Initialize() </p><p>device::VideoOutputPort::enable</p><p>device::VideoOutputPort::disable</p><p>device::VideoOutputPort::getDisplay()::getManufacturerWeek()</p><p>device::VideoOutputPort::getDisplay()::getManufacturerYear()</p><p>device::VideoOutputPort::getDisplay()::getProductCode()</p><p>device::VideoOutputPort::getDisplay()::getSerialNumber()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce19"><p>integer enable(0,1)</p><p>string port_name="HDMI0"</p></td><td style="text-align:left;width:127.64pt; " class="ce13"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce19"><p>1.TM loads the Device_Settings_Agent via the test agent </p><p>2. Set the Videooutput port to disable and get the details about the videoOutputPort.</p><p>3. Set the Videooutput port to enable and get the details about the videoOutputPort.</p><p>4.Device_Settings_Agent will list the details about videoOutputPort.</p></td><td style="text-align:left;width:99.89pt; " class="ce19"><p>Checkpoint 1 Check for return value of the devicedetails after port disable / enable .</p></td><td style="text-align:left;width:58.65pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce19"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_setEnable</p><p>TestMgr_DS_VOP_getDisplayDetails</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce19"><p>DS_GetDisplayDetails_OnDisabledPort_123</p></td><td style="text-align:left;width:64.2pt; " class="ce39"><p><span class="T10"><a href="https://www.teamccp.com/jira/browse/XITHREE-721">XITHREE-721 </a></span></p></td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M21</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS124</p></td><td style="text-align:left;width:128.44pt; " class="ce15"><p>Sets a valid time in the text display of given Front panel Indicator.</p></td><td style="text-align:left;width:44.39pt; " class="ce15"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce22"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce11"><p>device::Manager::Initialize()   </p><p>FrontPanelTextDisplay::getInstance("Text")</p><p>FrontPanelTextDisplay::setTime()</p><p><span class="T1">Device::Manager::DeInitialize()</span></p></td><td style="text-align:left;width:71.35pt; " class="ce3"><p>SetTime : int – hrs, int – mins</p><p>E.g.: hrs=04 mins=44s</p><p> </p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1.TM loads the Device_Settings_Agent via the test agent</p><p>2.Device_Settings_Agent will set a new time by passing “hrs” and “mins” value.</p><p>3.TM makes RPC calls for setting the Time format from Device_Settings_Agent.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step.</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check for the return value of setTime </span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setTime</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_SetTime_VALID_124.py</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>XONE-10478</p></td><td style="text-align:left;width:64.2pt; " class="ce35"> </td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce3"><p>CT_DS125</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>Sets and gets a valid brightness value in the text display of given Front panel Indicator.</p></td><td style="text-align:left;width:44.39pt; " class="ce15"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce22"><p>XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()                                  </p><p>FrontPanelTextDisplay::getInstance("Text")</p><p>FrontPanelTextDisplay::setText(string)</p><p>FrontPanelTextDisplay::setTextBrightness(int)      </p><p>FrontPanelTextDisplay::getTextBrightness()             </p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>integer brightness=100</p><p>string text="Hello"</p><p>integer get_only (0,1)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will set the front panel text to message "hello".</p><p>3. Device_Settings_Agent will set the brightness of front panel text value to brightness value.</p><p>4. Device_Settings_Agent will get the brightness value of front panel text and verify whether the brightness has changed.</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p> </p><p>Checkpoint 1<span class="T1">.Check for the brightness value of front panel text after and before setting the value of brightness.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_FP_setBrightness</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce35"><p>DS_SetTextBrightness_125</p></td><td style="text-align:left;width:64.2pt; " class="ce35"><p>XONE-11060</p></td><td style="text-align:left;width:64.2pt; " class="ce35"> </td></tr><tr class="ro34"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS126</p></td><td style="text-align:left;width:128.44pt; " class="ce16"><p>Verify if trickplay is successful after changing Device Settings Video resolution for HDMI to 480p and rebooting the Box.</p></td><td style="text-align:left;width:44.39pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce21"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce16"><p>device::Manager::Initialize() </p><p>device::VideoOutputPort::setResolution</p><p>device::VideoOutputPort::getResolution</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce30"><p><a href="http://ipaddress:8080/vldms/tuner?ocap_locator=ocap://ID">string resolution="480p"
string port_name="HDMI0"
integer get_only (0,1)
string playUrl='http://ipaddress:8080/vldms/tuner?ocap_locator=ocap://ID'</a></p></td><td style="text-align:left;width:127.64pt; " class="ce16"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce16"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will set the new display resolution.</p><p>3. Reboot the STB.</p><p>4. TDKIntegrationStub Agent will play the live Url after changing the resolution and return SUCCESS or FAILURE based on the result.</p></td><td style="text-align:left;width:99.89pt; " class="ce16"><p>Checkpoint 1. Check the display Resolution value before and after setting it.</p><p>Checkpoint 2. Check if the live trickplay is successful.</p></td><td style="text-align:left;width:58.65pt; " class="ce20"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce16"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_setResolution</p><p>TestMgr_LinearTv_Dvr_Play</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce20"><p>DS_Resolution480p_VideoPlay_126</p></td><td style="text-align:left;width:64.2pt; " class="ce20"><p>XONE-11008</p></td><td style="text-align:left;width:64.2pt; " class="ce16"><p>Testcase moved to tdk_integration as 'E2E_RMF_Resolution480p_Trickplay.py'</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS126</p></td><td style="text-align:left;width:128.44pt; " class="ce17"><p>Get the value of CPU temperature.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce13"><p>XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>device::Host::getCPUTemperature()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will get the value of cpu temperature.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether API execution is successful and value is within limit, more than 0 and less than 125C.</p></td><td style="text-align:left;width:99.89pt; " class="ce13"><p>Checkpoint 1.Check that cpu temperature value is more than 0 and less than 125C.</p></td><td style="text-align:left;width:58.65pt; " class="ce13"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_getCPUTemperature</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_GetCPUTemperature_126</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS127</p></td><td style="text-align:left;width:128.44pt; " class="ce17"><p>Performs stress test on get CPU Temperature</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce13"><p>XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>device::Host::getCPUTemperature()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will get the value of cpu temperature for 8 mins once in every 5sec.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether API execution is successful and value is within limit, more than 0 and less than 125C.</p></td><td style="text-align:left;width:99.89pt; " class="ce13"><p>Checkpoint 1.Check that cpu temperature value is more than 0 and less than 125C.</p></td><td style="text-align:left;width:58.65pt; " class="ce13"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_HOST_getCPUTemperature</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_GetCPUTemperature_STRESS_127</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS128</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>Test to enable HDCP authentication</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce13"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>device::VideoOutputPortType::enabledHDCP(protectContent,hdcpKey,keySize)</p><p>device::Host::getVideoOutputPort.getHDCPStatus()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>bool protectContent = 1, string key = '0', int keySize = 0, bool useMfrKey = 0</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will enable HDCP and get the status of authentication.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether hdcp status is authenticated.</p></td><td style="text-align:left;width:99.89pt; " class="ce13"><p>Checkpoint 1.Check HDCP enable should execute without error.</p><p>Checkpoint 2.HDCP status should be authenticated</p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_enableHDCP</p><p>TestMgr_DS_VOP_getHDCPStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_EnableHDCP_128</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS129</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>Test to enable HDCP authentication with HDMI display comnnected</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Negative</p></td><td style="text-align:left;width:75.29pt; " class="ce13"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>device::VideoOutputPortType::enabledHDCP(protectContent,hdcpKey,keySize)</p><p>device::Host::getVideoOutputPort.getHDCPStatus()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>bool protectContent = 1, string key = '0', int keySize = 0, bool useMfrKey = 0</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will enable HDCP and get the status of authentication.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether hdcp status is authenticated.</p></td><td style="text-align:left;width:99.89pt; " class="ce13"><p>Checkpoint 1.Check HDCP enable should execute without error.</p><p>Checkpoint 2.HDCP status should not be authenticated</p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_enableHDCP</p><p>TestMgr_DS_VOP_getHDCPStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_EnableHDCP_NoDisplay_129</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS130</p></td><td style="text-align:left;width:128.44pt; " class="ce16"><p>Test HDCP authentication without enabling content protection</p></td><td style="text-align:left;width:44.39pt; " class="ce16"><p>Negative</p></td><td style="text-align:left;width:75.29pt; " class="ce16"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce16"><p>device::Manager::Initialize() </p><p>device::VideoOutputPortType::enabledHDCP(protectContent,hdcpKey,keySize)</p><p>device::Host::getVideoOutputPort.getHDCPStatus()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce16"><p>bool protectContent = 0, string key = '0', int keySize = 0, bool useMfrKey = 0</p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce16"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will enable HDCP and get the status of authentication.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether hdcp status is authenticated.</p></td><td style="text-align:left;width:99.89pt; " class="ce16"><p>Checkpoint 1.Check HDCP enable should execute without error.</p><p>Checkpoint 2.HDCP status should not be authenticated</p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce16"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_enableHDCP</p><p>TestMgr_DS_VOP_getHDCPStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce16"><p>DS_EnableHDCP_NoContentProtection_130</p></td><td style="text-align:left;width:64.2pt; " class="ce16"><p> not applicable on broadcom</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M23</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS131</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>Test enable HDCP authentication with invalid key input</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Negative</p></td><td style="text-align:left;width:75.29pt; " class="ce13"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>device::VideoOutputPortType::enabledHDCP(protectContent,hdcpKey,keySize)</p><p>device::Host::getVideoOutputPort.getHDCPStatus()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>bool protectContent = 1, string key = 'ffff', int keySize = 1, bool useMfrKey = 0</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will enable HDCP and get the status of authentication.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether hdcp status is authenticated.</p></td><td style="text-align:left;width:99.89pt; " class="ce13"><p>Checkpoint 1.Check HDCP enable should execute without error.</p><p>Checkpoint 2.HDCP status should not be authenticated</p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_enableHDCP</p><p>TestMgr_DS_VOP_getHDCPStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_EnableHDCP_InvalidKey_131</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS132</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>Test enable HDCP authentication using invalid key size.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Negative</p></td><td style="text-align:left;width:75.29pt; " class="ce13"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>device::VideoOutputPortType::enabledHDCP(protectContent,hdcpKey,keySize)</p><p>device::Host::getVideoOutputPort.getHDCPStatus()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>bool protectContent = 1, string key = '0', int keySize = 1281, bool useMfrKey = 0</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will enable HDCP and get the status of authentication.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether hdcp status is authenticated.</p></td><td style="text-align:left;width:99.89pt; " class="ce13"><p>Checkpoint 1.Check HDCP enable should execute without error.</p><p>Checkpoint 2.HDCP status should not be authenticated</p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_enableHDCP</p><p>TestMgr_DS_VOP_getHDCPStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_EnableHDCP_InvalidKeySize_132</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS133</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>Tests enable HDCP authentication using manufacturer HDCP keys</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce13"><p>XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>device::VideoOutputPortType::enabledHDCP(protectContent,hdcpKey,keySize)</p><p>device::Host::getVideoOutputPort.getHDCPStatus()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>bool protectContent = 1, string key = '0', int keySize = 0, bool useMfrKey = 1</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p><p>3. mfrMgrMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will enable HDCP and get the status of authentication.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether hdcp status is authenticated.</p></td><td style="text-align:left;width:99.89pt; " class="ce13"><p>Checkpoint 1.Check HDCP enable should execute without error.</p><p>Checkpoint 2.HDCP status should be authenticated</p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_enableHDCP</p><p>TestMgr_DS_VOP_getHDCPStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_EnableHDCP_UsingMfrKey_133</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce4"><p>CT_DS134</p></td><td style="text-align:left;width:128.44pt; " class="ce16"><p>Stress test enable/disable HDCP authentication for 50 times.</p></td><td style="text-align:left;width:44.39pt; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce16"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce16"><p>device::Manager::Initialize() </p><p>device::VideoOutputPortType::enabledHDCP(protectContent,hdcpKey,keySize)</p><p>device::Host::getVideoOutputPort.getHDCPStatus()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce16"><p>bool protectContent = 0/1, string key = '0', int keySize = 0, bool useMfrKey = 0</p></td><td style="text-align:left;width:127.64pt; " class="ce4"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce16"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will enable HDCP and get the status of authentication.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether hdcp status is authenticated.</p></td><td style="text-align:left;width:99.89pt; " class="ce16"><p>Checkpoint 1.Check HDCP enable should execute without error.</p><p>Checkpoint 2.HDCP status should be authenticated with HDCP enabled and not authenticated with HDCP disabled</p></td><td style="text-align:left;width:58.65pt; " class="ce4"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce16"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOPTYPE_enableHDCP</p><p>TestMgr_DS_VOP_getHDCPStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce16"><p>DS_EnableDisableHDCP_Stress_134</p></td><td style="text-align:left;width:64.2pt; " class="ce16"><p>not applicable on broadcom</p></td><td style="text-align:left;width:64.2pt; " class="ce4"><p>M23</p></td></tr><tr class="ro36"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS135</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>Test get HDCP authentication status</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce13"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>device::Manager::Initialize() </p><p>device::Host::getVideoOutputPort.getHDCPStatus()</p><p>device::Manager::DeInitialize()</p><p> </p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce13"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2. Device_Settings_Agent will get the status of authentication.</p><p>3. Device_Settings_Agent will return SUCCESS or FAILURE based on whether execution is successful.</p></td><td style="text-align:left;width:99.89pt; " class="ce13"><p>Checkpoint 1.Check HDCP get status should execute without error.</p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>Medium</p></td><td style="text-align:left;width:132.41pt; " class="ce13"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_VOP_getHDCPStatus</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce13"><p>DS_GetHDCPStatus_135</p></td><td style="text-align:left;width:64.2pt; " class="ce13"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M23</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_136</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  This test is executed to get the Stereo Mode of SPDIF and expect the result to be SURROUND</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will check the current stereo format is SURROUND.</p><p>5.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step.</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the return values of API</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode </span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_getSPDIF_StereoMode_136</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_137</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  This test tries to set Stereo Mode to STEREO for SPDIF</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Negative</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: STEREO</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set and expect it to fail.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step. </p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_setSPDIF_STEREOFormat_137</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_138</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  This test tries to set Stereo Mode to SURROUND for SPDIF</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode :<span class="T1"> string</span></p><p><span class="T1">E.g.: SURROUND</span></p><p><span class="T6"/></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format set .</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step.</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_setSPDIF_SURROUNDFormat_138</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro13"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_139</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  This test tries to get the value of SPDIF after setting to STEREO and rebooting the device</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: STEREO</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4.Device_Settings_Agent will set new stereo format to STEREO.</p><p>5. Reboot the DUT.</p><p>6.Device_Settings_Agent will get the current stereo format.</p><p>7.Device_Settings_Agent will check the current stereo format with new stereo format set and expect the value to be SURROUND.</p><p>8.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_getSPDIF_SURROUND_AfterReboot_139</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro4"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_140</p></td><td style="text-align:left;width:128.44pt; " class="ce3"><p>Device Setting –  This test gets the stereo mode value of SPDIF before and after reboot</p></td><td style="text-align:left;width:44.39pt; " class="ce3"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce3"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce3"><p>device::Manager::Initialize()</p><p>Host::getVideoOutputPort()</p><p>Host::getAudioOutputPort()</p><p>AudioOutputPort::getSupportedStereoModes()</p><p>AudioOutputPort::getStereoMode()</p><p>AudioOutputPort::setStereoMode(string)</p><p>device::Manager::DeInitialize()</p></td><td style="text-align:left;width:71.35pt; " class="ce27"><p>setStereoMode<span class="T1"> : string</span></p><p><span class="T1">E.g.: STEREO</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the supported stereo modes.</p><p>3.Device_Settings_Agent will get the current stereo format.</p><p>4. Reboot the DUT.</p><p>5.Device_Settings_Agent will get the current stereo format.</p><p>6.Device_Settings_Agent will check the current stereo format with new stereo format and expect the value to be SURROUND.</p><p>7.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the current stereo mode is present in the list of supported stereo modes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check the stereo mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce3"><p>TestMgr_DS_managerInitialize</p><p>TestMgr_DS_AOP_getSupportedStereoModes</p><p>TestMgr_DS_AOP_setStereoMode</p><p>TestMgr_DS_managerDeinitialize</p></td><td style="text-align:left;width:273.54pt; " class="ce3"><p>DS_getSPDIF_SURROUND_Persistent_AfterReboot_140</p></td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro5"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_141</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script allows the application to set the runtime version of the dsHAL.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce7"><p>void Host::setVersion(uint32_t versionNumber)</p><p>uint32_t  Host::getVersion(void)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int versionNo</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the current ds HAL version number.</p><p>3.Device_Settings_Agent will set the version number of ds HAL.</p><p>4.Device_Settings_Agent will get the  version number of ds HAL.</p><p>5.Device_Settings_Agent will check the current version number with the version number set and expect it to match.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the version number before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_Host_setVersion_141</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_142</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to set the Preferred sleep Mode and implements the low power mode for RDK platform.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce7"><p>int setPreferredSleepMode(const SleepMode mode)</p><p>SleepMode getPreferredSleepMode()</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string sleepMode ("LIGHT_SLEEP","DEEP_SLEEP")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the  list of supported preferred sleep modes.</p><p>3.Device_Settings_Agent will set the preferred sleep mode to supported values.</p><p>4.Device_Settings_Agent will get the preferred sleep mode.</p><p>5.Device_Settings_Agent will check the preferred sleep mode retrieved with preferred sleep mode set and expect it to match.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the preferred sleep mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_setPreferredSleepMode_142</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_143</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This test script is used to gets the Preferred sleep Mode and implements the low power mode for RDK platform.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce7"><p>SleepMode Host::getPreferredSleepMode()</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the preferred sleep mode.</p><p>3.Device_Settings_Agent will check if the retrieved preferred sleep mode is in valid range (light sleep, deep sleep).</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the preferred sleep mode is 0 or 1.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getPreferredSleepMode_143</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_144</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get the list of the video output ports supported on the device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce7"><p>List&lt;VideoOutputPort&gt; getVideoOutputPorts()</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported video output ports.</p><p>3.Device_Settings_Agent will check if atleast one video output ports is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one video output port is supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getVideoOutputPorts_144</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_145</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get the list of the audio output ports supported on the device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>List&lt;AudioOutputPort&gt; getAudioOutputPorts()</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported audio output ports.</p><p>3.Device_Settings_Agent will check if atleast one audio output ports is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one audio output port is supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getAudioOutputPorts_145</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_146</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get the list of the video devices (i.e. Decoders) supported on the device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>List&lt;VideoDevice&gt; getVideoDevices()</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported video devices.</p><p>3.Device_Settings_Agent will check if atleast one video device is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one video device is supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getVideoDevices_146</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_147</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get the EDID information of the host device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void getHostEDID(std::vector&lt;uint8_t&gt; &amp;edid)</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the Host EDID bytes.</p><p>3.Device_Settings_Agent will check if EDID Checksum is valid.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check EDID value is at least 128 bytes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check EDID Checksum is valid.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getHostEDID_147</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_148</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get the reference to the video output port by its name.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>VideoOutputPort &amp;getVideoOutputPort(const std::string &amp;name)</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string port_name ("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the video output port instance by portname.</p><p>3.Device_Settings_Agent will check if port name retrieved using port instance is same as portname provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if port name retrieved using port instance is same as port name provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getVideoOutputPortFromName_148</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_149</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get a reference to the video output port by its id.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>VideoOutputPort &amp;getVideoOutputPort(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int port_id (0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the video output port instance by port id</p><p>3.Device_Settings_Agent will check if port id retrieved using port instance is same as port id provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if port id retrieved using port instance is same as port id provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getVideoOutputPortFromId_149</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_150</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get the reference to the audio output port by its name.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>AudioOutputPort &amp;getAudioOutputPort(const std::string &amp;name)</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string port_name ("SPDIF0","HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the audio output port instance by portname.</p><p>3.Device_Settings_Agent will check if port name retrieved using port instance is same as port name provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if port name retrieved using port instance is same as port name provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getAudioOutputPortFromName_150</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_151</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get a reference to the Audio output port by its id.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>AudioOutputPort &amp;getAudioOutputPort(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int port_id (0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the audio output port instance by port id</p><p>3.Device_Settings_Agent will check if port id retrieved using port instance is same as port id provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if port id retrieved using port instance is same as port id provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getAudioOutputPortFromId_151</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_152</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script gets the maximum brightness, minimum brightness and the brightness level.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void getBrightnessLevels(int &amp;levels, int &amp;min, int &amp;max)</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string indicator_name ("Message", "Power", "Record", "Remote" and "RfByPass")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the brightness levels, min value and max value for given front panel indicator.</p><p>3.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if brightness levels are retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FP_getBrightnessLevels_152</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_153</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get the color mode (single or multi color mode) of the front panel indicator.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>int  getColorMode()</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string indicator_name ("Message", "Power", "Record", "Remote" and "RfByPass")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the front panel indicator color mode.</p><p>3.Device_Settings_Agent will check if color mode is in range single or multi color mode.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if color mode is 0 or 1 indicating single or multi color mode</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FP_getColorMode_153</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_154</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This test script is used to get the color mode of the front panel text display.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>int getTextColorMode()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the front panel text color mode.</p><p>3.Device_Settings_Agent will check if color mode is in range single or multi color mode.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if color mode is 0 or 1 indicating single or multi color mode</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FP_getTextColorMode_154</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro33"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_155</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to get maximum brightness, minimum brightness and brightness level of the front panel LED display</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>void getTextBrightnessLevels(int &amp;levels, int &amp;min, int &amp;max)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the brightness levels, min value and max value for given front panel text.</p><p>3.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if brightness levels are retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FP_getTextBrightnessLevels_155</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_156</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This test script is used to get the available sleep modes.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>List&lt;SleepMode&gt; getAvailableSleepModes()</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of available sleep modes.</p><p>3.Device_Settings_Agent will check if at least one sleep mode is retrieved.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one sleep mode is retrieved</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_HOST_getAvailableSleepModes_156</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_157</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script sets the brightness value for the front panel LED.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void setTextBrightness(const int &amp;brightness)</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>int brightness</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the front panel text brightness level.</p><p>3.Device_Settings_Agent will get the text brightness level and compare with value set in above step.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if text brightness level set is same as value retrieved</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FP_setTextBrightness_157</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro36"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_158</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This test script gets the text LED brightness value.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>int getTextBrightness()</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the front panel text brightness level.</p><p>3.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if text brightness level is retrieved successfully.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FP_getTextBrightness_158</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_159</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to enable or disable the display of clock on front panel.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void enableDisplay(const int enable)</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>bool enable</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will enable or disable FrontPanelTextDisplay.</p><p>3.Device_Settings_Agent will check FrontPanelTextDisplay is enabled or disabled successfully.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if frontPanelTextDisplay is enabled or disabled successfully.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FP_enableDisplay_159</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro11"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_160</p></td><td style="text-align:left;width:128.44pt; " class="ce7"><p>This test script is used to set the Preferred sleep Mode to an unsupported value.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Negative</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce7"><p>int setPreferredSleepMode(const SleepMode mode)</p><p>getPreferredSleepMode()</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string sleepMode ("TIGHT_SLEEP")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the  list of supported preferred sleep modes.</p><p>3.Device_Settings_Agent will set the preferred sleep mode to unsupported value.</p><p>4.Device_Settings_Agent will get the preferred sleep mode.</p><p>5.Device_Settings_Agent will check the preferred sleep mode retrieved with preferred sleep mode set and expect it to match.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the preferred sleep mode setting should be denied.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce33"><p>DS_HOST_setPreferred_Invalid_SleepMode_160</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_161</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API gets the FrontPanelndicator instance corresponding to the name parameter returned by the get supported frontpanel indicator device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce25"><p>FrontPanelIndicator &amp;getIndicator(const string &amp;name)</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string indicator_name ("Message", "Power", "Record", "Remote" and "RfByPass")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the front panel indicator instance by indicator name.</p><p>3.Device_Settings_Agent will check if indicator name retrieved using front panel indicator instance is same as indicator name provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if indicator name retrieved using front panel indicator instance is same as indicator name provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FPCONFIG_getIndicatorFromName_161</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_162</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This function gets an instance of the FrontPanelndicator with the specified id, only if the id passed is valid.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce25"><p>FrontPanelIndicator &amp;getIndicator(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>int indicator_id</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the front panel indicator instance by indicator id</p><p>3.Device_Settings_Agent will check if indicator id retrieved using front panel indicator instance is same as indicator id provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if indicator id retrieved using front panel indicator instance is same as indicator id provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FPCONFIG_getIndicatorFromId_162</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_163</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API gets the FrontPanelTextDisplay instance corresponding to the name parameter, only if the name passed is valid.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce25"><p>FrontPanelTextDisplay &amp;getTextDisplay(const string &amp;name)</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>string text_name="Text"</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the front panel text instance by text name.</p><p>3.Device_Settings_Agent will check if text name retrieved using front panel text instance is same as text name provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if text name retrieved using front panel text instance is same as text name provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FPCONFIG_getTextDisplayFromName_163</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_164</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This function gets the FrontPanelTextDisplay instance corresponding to the specified id, only if the id passed is valid.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce25"><p>FrontPanelTextDisplay &amp;getTextDisplay(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>int text_id(0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the front panel text instance by text id</p><p>3.Device_Settings_Agent will check if text id retrieved using front panel text instance is same as text id provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if text id retrieved using front panel text instance is same as text id provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FPCONFIG_getTextDisplayFromId_164</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_165</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to get the type of the audio output port</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>AudioOutputPortType &amp;getPortType(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>int port_id (0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the audio output port type by port id.</p><p>3.Device_Settings_Agent will check if audio output port id retrieved using audio output port type is same as port id provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if audio output port id retrieved using audio output port type is same as port id provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOPCONFIG_getPortType_165</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_166</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to get the type of the audio output port from port name</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce25"><p>AudioOutputPort  &amp;getPort(const std::string &amp;name)</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string port_name ("SPDIF0","HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the audio output port instance by port name.</p><p>3.Device_Settings_Agent will check if audio output port name retrieved using audio output port instance is same as port name provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if port name retrieved using audio output port instance is same as port name provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOPCONFIG_getPortFromName_166</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_167</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to get the type of the audio output port from port id</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce25"><p>AudioOutputPort  &amp;getPort(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>int port_id (0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the audio output port instance by port id.</p><p>3.Device_Settings_Agent will check if audio output port id retrieved using audio output port instance is same as port id provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if port id retrieved using audio output port instance is same as port id provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOPCONFIG_getPortFromId_167</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce8"><p>CT_DS_168</p></td><td style="text-align:left;width:128.44pt; " class="ce18"><p>This API is used to get the list of audio output ports</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>List&lt;AudioOutputPort&gt; getPorts()</p></td><td style="text-align:left;width:71.35pt; " class="ce15"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported audio ports.</p><p>3.Device_Settings_Agent will check if atleast one audio output port is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one audio output port is supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOPCONFIG_getPorts_168</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce8"><p>CT_DS_169</p></td><td style="text-align:left;width:128.44pt; " class="ce18"><p>This API is used to get the list of audio output port types</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>List&lt;AudioOutputPortType&gt; getSupportedTypes()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported audio port types.</p><p>3.Device_Settings_Agent will check if atleast one audio output port type is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one audio output port type is supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOPCONFIG_getSupportedTypes_169</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce8"><p>CT_DS_170</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API clears the instance of audio encoding, compression, stereo modes and audio port types.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>void release()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will release instance of audio encoding, compression, stereo modes and audio port types.</p><p>3.Device_Settings_Agent will check if audio output ports and port types are not supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if audio output ports and port types are not supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOPCONFIG_release_170</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce8"><p>CT_DS_171</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API will load constants first and initialize Audio portTypes (encodings, compressions etc.)</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>void load()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will load instance of audio encoding, compression, stereo modes and audio port types.</p><p>3.Device_Settings_Agent will check if at least one audio output ports and port types are supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one audio output ports and port types are supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOPCONFIG_load_171</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_172</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to get the default resolution supported by the video output port.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce13"><p>const VideoResolution &amp;getDfeaultResolution()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the default resolution for video output port.</p><p>3.Device_Settings_Agent will check if default Resolution is retrieved successfully</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check  if default resolution is retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VOP_getDefaultResolution_172</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro13"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_173</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to set the stereo mode to be auto.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void setStereoAuto(const bool autoMode)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int autoMode(0,1)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the audio output port stereo auto mode.</p><p>3.Device_Settings_Agent will set the audio output port stereo auto mode.</p><p>4.Device_Settings_Agent will get the  audio output port stereo auto mode.</p><p>5.Device_Settings_Agent will check the current stereo auto mode with the auto mode set and expect it to match.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the stereo auto mode before and after setting it.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOP_setStereoAuto_173</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_174</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to get the current auto mode.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>bool getStereoAuto()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the audio output port stereo auto mode.</p><p>3.Device_Settings_Agent will check the current stereo auto mode is retrieved successfully.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check the stereo auto mode  is retrieved successfully.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOP_getStereoAuto_174</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_175</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API will get the current Gain for the given audio output port.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>float getGain()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the gain value for audio output port.</p><p>3.Device_Settings_Agent will check if gain value is retrieved successfully</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check  if gain value is retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOP_getGain_175</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_176</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to get the current optimal level value for audio  output port.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>float getOptimalLevel()</p></td><td style="text-align:left;width:71.35pt; " class="ce7"><p>string port_name ("SPDIF0","HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the optimal level value for audio output port.</p><p>3.Device_Settings_Agent will check if optimal level value is retrieved successfully</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check  if optimal level value is retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_AOP_getOptimalLevel_176</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro36"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_177</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to check if Port is connected to active port of Sink device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>bool isActive()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the if audio output port is active.</p><p>3.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check  if isActive value is retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VOP_isActive_177</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_178</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This API is used to set the video output port display to be connected.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void setDisplayConnected(const bool connected)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p><p>int connected (0,1)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set video output port display connection to enable or disable.</p><p>3.Device_Settings_Agent will check video output port display connection is enabled or disabled successfully.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if video output port display connection is enabled or disabled successfully.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VOP_setDisplayConnected_178</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro33"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_179</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This function returns true if connected display supports surround audio.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>bool hasSurround(void)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the if audio output port has surround.</p><p>3.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check  if hasSurround value is retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VOP_hasSurround_179</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_180</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This function is used to get the EDID information of the connected video display.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void getEDIDBytes(std::vector&lt;uint8_t&gt; &amp;edid)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get   EDID bytes for given video putput port name.</p><p>3.Device_Settings_Agent will check if EDID Checksum is valid.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check EDID value is at least 128 bytes.</span></p><p><span class="T6">Checkpoint 2.</span><span class="T7"> Check EDID Checksum is valid.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VOP_getEDIDBytes_180</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro33"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_181</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This checks if the video is interlaced or not.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>bool isInterlaced()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the if resolution of video output port is interlaced.</p><p>3.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check  if isInterlaced value for resolution of video output port retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoResolution_isInterlaced_181</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_182</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests get default DFC for video device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>VideoDFC &amp; getDefaultDFC()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get   default DFC value for video device</p><p>3.Device_Settings_Agent will check if default DFC value for video device is retrieved successfully.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if default DFC value for video device is retrieved successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoDevice_getDefaultDFC_182</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_183</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests get of supported DFCs by the video device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>List&lt;VideoDFC&gt;  getDFCs()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported dfcs.</p><p>3.Device_Settings_Agent will check if atleast one dfc is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one dfc is supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoDevice_getDFCs_183</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_184</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests get to fetch the list of the video devices (i.e. Decoders) supported on the device.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>List&lt;VideoDevice&gt;  getDevices()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported video devices</p><p>3.Device_Settings_Agent will check if atleast one video device is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one video device is supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoDevice_getDevices_184</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro16"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_185</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests get to fetch the list of supported DFC (i.e. Zoom Settings) for decoder.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>const List &lt;VideoDFC&gt;  getSupportedDFCs()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported dfcs.</p><p>3.Device_Settings_Agent will check if atleast one dfc is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one dfc is supported</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoDevice_getSupportedDFCs_185</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro33"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_186</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API to set the zoom setting to the default one supported by the platform.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void setPlatformDFC()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set the default zoom setting supported by platform.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check zoom setting is set successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoDevice_setPlatformDFC_186</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_187</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API to get supported video output port types.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>List&lt;VideoOutputPortType&gt; getSupportedTypes()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported video output port types.</p><p>3.Device_Settings_Agent will check if at least one  video output port type is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one at least one  video output port type is supported.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPort_getSupportedTypes_187</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_188</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests the API used to get video output port instance using port Id.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce25"><p>VideoOutputPort getPort(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int port_id (0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the video output port instance by port id.</p><p>3.Device_Settings_Agent will check if video output port id retrieved using video output port instance is same as port id provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if port id retrieved using video output port instance is same as port id provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPort_getPortFromId_188</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro7"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_189</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests the API used to get video output port instance using port name.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce25"><p>VideoOutputPort getPort(const std::string &amp; name)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the video output port instance by port name.</p><p>3.Device_Settings_Agent will check if video output port name retrieved using video output port instance is same as port name provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if port name retrieved using video output port instance is same as port name provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPort_getPortFromName_189</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_190</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests the API used to get the type of the video output port.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>VideoOutputPortType &amp;getPortType(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int port_id (0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the video output port type by port id.</p><p>3.Device_Settings_Agent will check if video output port id retrieved using video output port type is same as port id provided.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if video output port id retrieved using video output port type is same as port id provided</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPort_getPortType_190</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_191</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests the API used to get the frame rate of the given video output port.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>const FrameRate &amp; getFrameRate()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the frame rate of video output port.</p><p>3.Device_Settings_Agent will check if frame rate of video output port is retrievd successfully.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if frame rate of video output port is retrievd successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPort_getFrameRate_191</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_192</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API used to get a list of supported Video Resolutions by the port type.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>const VideoResolution   &amp;getVideoResolution (int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int port_id (0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the video resolution of video output port.</p><p>3.Device_Settings_Agent will check if video resolution of video output port is retrievd successfully.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if video resolution of video output port is retrievd successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPort_getVideoResolution_192</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_193</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API used to get the Stereo Scopic Mode of the given video output port.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>const StereoScopicMode  &amp;getSSMode(int id)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int ss_id(0,1,2,3))</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the ssmode of given ss id.</p><p>3.Device_Settings_Agent will check if ssmode of given ss id is retrievd successfully.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if ssmode of given ss id is retrievd successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPort_getSSMode_193</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_194</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API used to get the pixel resolution of the given video output port.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>const PixelResolution &amp; getPixelResolution()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the pixel resolution of video output port.</p><p>3.Device_Settings_Agent will check if pixel resolution of video output port is retrievd successfully.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if pixel resolution of video output port is retrievd successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPort_getPixelResolution_194</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_195</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API used to get the resolution type which has been restricted from usage.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>int getRestrictedResolution()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the restricted resolution of video output port.</p><p>3.Device_Settings_Agent will check if restricted resolution of video output port is retrievd successfully.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if restricted resolution of video output port is retrievd successfully</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPortType_getRestrictedResolution_195</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_196</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API used to set the restricted resolution of the video output port type.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>void setRestrictedResolution(int resolution)</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p><p>int resolution(0 to 4)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will set restricted resolution of video output port.</p><p>3.Device_Settings_Agent will check restricted resolution of video output port is set successfully.</p><p>6.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check restricted resolution value before and after setting resolution value.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPortType_setRestrictedResolution_196</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_197</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests function used to get the list of video output port type.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>const List&lt;VideoOutputPort&gt;getPorts()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>int port_id (0)</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported video output port types.</p><p>3.Device_Settings_Agent will check if at least one  video output port type is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one at least one  video output port type is supported.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPortType_getPorts_197</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro9"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_198</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API used to get a list of supported Video Resolutions by the port type.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>const List&lt;VideoResolution&gt;  getSupportedResolutions()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>string port_name("HDMI0")</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported resolutions for given video output port.</p><p>3.Device_Settings_Agent will check if at least one resolution is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one at least one  resolution is supported.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_VideoOutputPortType_getSupportedResolutions_198</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro35"><td style="text-align:left;width:122.91pt; " class="ce7"><p>CT_DS_199</p></td><td style="text-align:left;width:128.44pt; " class="ce13"><p>This tests API used to get the list of colors supported by front panel indicators.</p></td><td style="text-align:left;width:44.39pt; " class="ce13"><p>Positive</p></td><td style="text-align:left;width:75.29pt; " class="ce23"><p>XI3-1/XG1-1</p></td><td style="text-align:left;width:148.25pt; " class="ce18"><p>List&lt;FrontPanelIndicator::Color&gt;  FrontPanelConfig::getColors()</p></td><td style="text-align:left;width:71.35pt; " class="ce13"><p>None</p></td><td style="text-align:left;width:127.64pt; " class="ce3"><p>1. dsMgrMain should be up and running.</p><p>2. IARMDaemonMain should be up and running.</p></td><td style="text-align:left;width:175.21pt; " class="ce3"><p>1. TM loads the Device_Settings_Agent via the test agent.</p><p>2.Device_Settings_Agent will get the list of supported colors for front panel indicators.</p><p>3.Device_Settings_Agent will check if at least one color is supported.</p><p>4.Device_Settings_Agent will return SUCCESS or FAILURE based on the result from the above step</p></td><td style="text-align:left;width:99.89pt; " class="ce26"><p>Checkpoint 1.<span class="T1"> Check if at least one at least one color is supported.</span></p></td><td style="text-align:left;width:58.65pt; " class="ce3"><p>High</p></td><td style="text-align:left;width:132.41pt; " class="ce33"> </td><td style="text-align:left;width:273.54pt; " class="ce36"><p>DS_FP_getColors_199</p></td><td style="text-align:left;width:64.2pt; " class="ce33"> </td><td style="text-align:left;width:64.2pt; " class="ce7"><p>M27</p></td></tr><tr class="ro37"><td style="text-align:left;width:122.91pt; " class="ce9"> </td><td style="text-align:left;width:128.44pt; " class="ce9"> </td><td style="text-align:left;width:44.39pt; " class="ce9"> </td><td style="text-align:left;width:75.29pt; " class="ce9"> </td><td style="text-align:left;width:148.25pt; " class="ce9"> </td><td style="text-align:left;width:71.35pt; " class="ce9"> </td><td style="text-align:left;width:127.64pt; " class="ce9"> </td><td style="text-align:left;width:175.21pt; " class="ce9"> </td><td style="text-align:left;width:99.89pt; " class="ce9"> </td><td style="text-align:left;width:58.65pt; " class="ce9"> </td><td style="text-align:left;width:132.41pt; " class="ce9"> </td><td style="text-align:left;width:273.54pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro37"><td style="text-align:left;width:122.91pt; " class="ce9"> </td><td style="text-align:left;width:128.44pt; " class="ce9"> </td><td style="text-align:left;width:44.39pt; " class="ce9"> </td><td style="text-align:left;width:75.29pt; " class="ce9"> </td><td style="text-align:left;width:148.25pt; " class="ce9"> </td><td style="text-align:left;width:71.35pt; " class="ce9"> </td><td style="text-align:left;width:127.64pt; " class="ce9"> </td><td style="text-align:left;width:175.21pt; " class="ce9"> </td><td style="text-align:left;width:99.89pt; " class="ce9"> </td><td style="text-align:left;width:58.65pt; " class="ce9"> </td><td style="text-align:left;width:132.41pt; " class="ce9"> </td><td style="text-align:left;width:273.54pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="ce9"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr></table></body></html>
